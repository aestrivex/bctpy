<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Brain Connectivity Toolbox &mdash; bct 0.4 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="bct 0.4 documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="index.html">bct 0.4 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="brain-connectivity-toolbox">
<h1>Brain Connectivity Toolbox<a class="headerlink" href="#brain-connectivity-toolbox" title="Permalink to this headline">¶</a></h1>
<div class="section" id="centrality">
<h2>Centrality<a class="headerlink" href="#centrality" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="bct.betweenness_bin">
<tt class="descclassname">bct.</tt><tt class="descname">betweenness_bin</tt><big>(</big><em>G</em><big>)</big><a class="headerlink" href="#bct.betweenness_bin" title="Permalink to this definition">¶</a></dt>
<dd><p>Node betweenness centrality is the fraction of all shortest paths in
the network that contain a given node. Nodes with high values of
betweenness centrality participate in a large number of shortest paths.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary directed/undirected connection matrix</p>
</div></blockquote>
<p><strong>BC</strong> : Nx1 np.ndarray</p>
<blockquote class="last">
<div><p>node betweenness centrality vector</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Betweenness centrality may be normalised to the range [0,1] as
BC/[(N-1)(N-2)], where N is the number of nodes in the network.</p>
</dd></dl>

<dl class="function">
<dt id="bct.betweenness_wei">
<tt class="descclassname">bct.</tt><tt class="descname">betweenness_wei</tt><big>(</big><em>G</em><big>)</big><a class="headerlink" href="#bct.betweenness_wei" title="Permalink to this definition">¶</a></dt>
<dd><p>Node betweenness centrality is the fraction of all shortest paths in
the network that contain a given node. Nodes with high values of
betweenness centrality participate in a large number of shortest paths.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>L</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>directed/undirected weighted connection matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>BC</strong> : Nx1 np.ndarray</p>
<blockquote class="last">
<div><p>node betweenness centrality vector</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<dl class="docutils">
<dt>The input matrix must be a connection-length matrix, typically</dt>
<dd>obtained via a mapping from weight to length. For instance, in a
weighted correlation network higher correlations are more naturally
interpreted as shorter distances and the input matrix should
consequently be some inverse of the connectivity matrix.</dd>
<dt>Betweenness centrality may be normalised to the range [0,1] as</dt>
<dd>BC/[(N-1)(N-2)], where N is the number of nodes in the network.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.diversity_coef_sign">
<tt class="descclassname">bct.</tt><tt class="descname">diversity_coef_sign</tt><big>(</big><em>W</em>, <em>ci</em><big>)</big><a class="headerlink" href="#bct.diversity_coef_sign" title="Permalink to this definition">¶</a></dt>
<dd><p>The Shannon-entropy based diversity coefficient measures the diversity
of intermodular connections of individual nodes and ranges from 0 to 1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>undirected connection matrix with positive and negative weights</p>
</div></blockquote>
<p><strong>ci</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>community affiliation vector</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Hpos</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>diversity coefficient based on positive connections</p>
</div></blockquote>
<p><strong>Hneg</strong> : Nx1 np.ndarray</p>
<blockquote class="last">
<div><p>diversity coefficient based on negative connections</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.edge_betweenness_bin">
<tt class="descclassname">bct.</tt><tt class="descname">edge_betweenness_bin</tt><big>(</big><em>G</em><big>)</big><a class="headerlink" href="#bct.edge_betweenness_bin" title="Permalink to this definition">¶</a></dt>
<dd><p>Edge betweenness centrality is the fraction of all shortest paths in
the network that contain a given edge. Edges with high values of
betweenness centrality participate in a large number of shortest paths.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary directed/undirected connection matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>EBC</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>edge betweenness centrality matrix</p>
</div></blockquote>
<p><strong>BC</strong> : Nx1 np.ndarray</p>
<blockquote class="last">
<div><p>node betweenness centrality vector</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Betweenness centrality may be normalised to the range [0,1] as
BC/[(N-1)(N-2)], where N is the number of nodes in the network.</p>
</dd></dl>

<dl class="function">
<dt id="bct.edge_betweenness_wei">
<tt class="descclassname">bct.</tt><tt class="descname">edge_betweenness_wei</tt><big>(</big><em>G</em><big>)</big><a class="headerlink" href="#bct.edge_betweenness_wei" title="Permalink to this definition">¶</a></dt>
<dd><p>Edge betweenness centrality is the fraction of all shortest paths in
the network that contain a given edge. Edges with high values of
betweenness centrality participate in a large number of shortest paths.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>L</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>directed/undirected weighted connection matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>EBC</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>edge betweenness centrality matrix</p>
</div></blockquote>
<p><strong>BC</strong> : Nx1 np.ndarray</p>
<blockquote class="last">
<div><p>nodal betweenness centrality vector</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<dl class="docutils">
<dt>The input matrix must be a connection-length matrix, typically</dt>
<dd>obtained via a mapping from weight to length. For instance, in a
weighted correlation network higher correlations are more naturally
interpreted as shorter distances and the input matrix should
consequently be some inverse of the connectivity matrix.</dd>
<dt>Betweenness centrality may be normalised to the range [0,1] as</dt>
<dd>BC/[(N-1)(N-2)], where N is the number of nodes in the network.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.eigenvector_centrality_und">
<tt class="descclassname">bct.</tt><tt class="descname">eigenvector_centrality_und</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.eigenvector_centrality_und" title="Permalink to this definition">¶</a></dt>
<dd><p>Eigenector centrality is a self-referential measure of centrality:
nodes have high eigenvector centrality if they connect to other nodes
that have high eigenvector centrality. The eigenvector centrality of
node i is equivalent to the ith element in the eigenvector
corresponding to the largest eigenvalue of the adjacency matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary/weighted undirected adjacency matrix</p>
</div></blockquote>
<p><strong>v</strong> : Nx1 np.ndarray</p>
<blockquote class="last">
<div><p>eigenvector associated with the largest eigenvalue of the matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.flow_coef_bd">
<tt class="descclassname">bct.</tt><tt class="descname">flow_coef_bd</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.flow_coef_bd" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the flow coefficient for each node and averaged over the
network, as described in Honey et al. (2007) PNAS. The flow coefficient
is similar to betweenness centrality, but works on a local
neighborhood. It is mathematically related to the clustering
coefficient  (cc) at each node as, fc+cc &lt;= 1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary directed connection matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fc</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>flow coefficient for each node</p>
</div></blockquote>
<p><strong>FC</strong> : float</p>
<blockquote>
<div><p>average flow coefficient over the network</p>
</div></blockquote>
<p><strong>total_flo</strong> : int</p>
<blockquote class="last">
<div><p>number of paths that &#8220;flow&#8221; across the central node</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.kcoreness_centrality_bd">
<tt class="descclassname">bct.</tt><tt class="descname">kcoreness_centrality_bd</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.kcoreness_centrality_bd" title="Permalink to this definition">¶</a></dt>
<dd><p>The k-core is the largest subgraph comprising nodes of degree at least
k. The coreness of a node is k if the node belongs to the k-core but
not to the (k+1)-core. This function computes k-coreness of all nodes
for a given binary directed connection matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary directed connection matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>coreness</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>node coreness</p>
</div></blockquote>
<p><strong>kn</strong> : int</p>
<blockquote class="last">
<div><p>size of k-core</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.kcoreness_centrality_bu">
<tt class="descclassname">bct.</tt><tt class="descname">kcoreness_centrality_bu</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.kcoreness_centrality_bu" title="Permalink to this definition">¶</a></dt>
<dd><p>The k-core is the largest subgraph comprising nodes of degree at least
k. The coreness of a node is k if the node belongs to the k-core but
not to the (k+1)-core. This function computes the coreness of all nodes
for a given binary undirected connection matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary undirected connection matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>coreness</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>node coreness</p>
</div></blockquote>
<p><strong>kn</strong> : int</p>
<blockquote class="last">
<div><p>size of k-core</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.module_degree_zscore">
<tt class="descclassname">bct.</tt><tt class="descname">module_degree_zscore</tt><big>(</big><em>W</em>, <em>ci</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#bct.module_degree_zscore" title="Permalink to this definition">¶</a></dt>
<dd><p>The within-module degree z-score is a within-module version of degree
centrality.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.narray</p>
<blockquote>
<div><p>binary/weighted directed/undirected connection matrix</p>
</div></blockquote>
<p><strong>ci</strong> : Nx1 np.array_like</p>
<blockquote>
<div><p>community affiliation vector</p>
</div></blockquote>
<p><strong>flag</strong> : int</p>
<blockquote>
<div><dl class="docutils">
<dt>Graph type. 0: undirected graph (default)</dt>
<dd><p class="first last">1: directed graph in degree
2: directed graph out degree
3: directed graph in and out degree</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Z</strong> : Nx1 np.ndarray</p>
<blockquote class="last">
<div><p>within-module degree Z-score</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.pagerank_centrality">
<tt class="descclassname">bct.</tt><tt class="descname">pagerank_centrality</tt><big>(</big><em>A</em>, <em>d</em>, <em>falff=None</em><big>)</big><a class="headerlink" href="#bct.pagerank_centrality" title="Permalink to this definition">¶</a></dt>
<dd><p>The PageRank centrality is a variant of eigenvector centrality. This
function computes the PageRank centrality of each vertex in a graph.</p>
<p>Formally, PageRank is defined as the stationary distribution achieved
by instantiating a Markov chain on a graph. The PageRank centrality of
a given vertex, then, is proportional to the number of steps (or amount
of time) spent at that vertex as a result of such a process.</p>
<p>The PageRank index gets modified by the addition of a damping factor,
d. In terms of a Markov chain, the damping factor specifies the
fraction of the time that a random walker will transition to one of its
current state&#8217;s neighbors. The remaining fraction of the time the
walker is restarted at a random vertex. A common value for the damping
factor is d = 0.85.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : NxN np.narray</p>
<blockquote>
<div><p>adjacency matrix</p>
</div></blockquote>
<p><strong>d</strong> : float</p>
<blockquote>
<div><p>damping factor (see description)</p>
</div></blockquote>
<p><strong>falff</strong> : Nx1 np.ndarray | None</p>
<blockquote>
<div><p>Initial page rank probability, non-negative values. Default value is
None. If not specified, a naive bayesian prior is used.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>r</strong> : Nx1 np.ndarray</p>
<blockquote class="last">
<div><p>vectors of page rankings</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Note: The algorithm will work well for smaller matrices (number of
nodes around 1000 or less)</p>
</dd></dl>

<dl class="function">
<dt id="bct.participation_coef">
<tt class="descclassname">bct.</tt><tt class="descname">participation_coef</tt><big>(</big><em>W</em>, <em>ci</em>, <em>degree='undirected'</em><big>)</big><a class="headerlink" href="#bct.participation_coef" title="Permalink to this definition">¶</a></dt>
<dd><p>Participation coefficient is a measure of diversity of intermodular
connections of individual nodes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary/weighted directed/undirected connection matrix</p>
</div></blockquote>
<p><strong>ci</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>community affiliation vector</p>
</div></blockquote>
<p><strong>degree</strong> : str</p>
<blockquote>
<div><dl class="docutils">
<dt>Flag to describe nature of graph &#8216;undirected&#8217;: For undirected graphs</dt>
<dd><p class="first last">&#8216;in&#8217;: Uses the in-degree
&#8216;out&#8217;: Uses the out-degree</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>P</strong> : Nx1 np.ndarray</p>
<blockquote class="last">
<div><p>participation coefficient</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.participation_coef_sign">
<tt class="descclassname">bct.</tt><tt class="descname">participation_coef_sign</tt><big>(</big><em>W</em>, <em>ci</em><big>)</big><a class="headerlink" href="#bct.participation_coef_sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Participation coefficient is a measure of diversity of intermodular
connections of individual nodes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>undirected connection matrix with positive and negative weights</p>
</div></blockquote>
<p><strong>ci</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>community affiliation vector</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Ppos</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>participation coefficient from positive weights</p>
</div></blockquote>
<p><strong>Pneg</strong> : Nx1 np.ndarray</p>
<blockquote class="last">
<div><p>participation coefficient from negative weights</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.subgraph_centrality">
<tt class="descclassname">bct.</tt><tt class="descname">subgraph_centrality</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.subgraph_centrality" title="Permalink to this definition">¶</a></dt>
<dd><p>The subgraph centrality of a node is a weighted sum of closed walks of
different lengths in the network starting and ending at the node. This
function returns a vector of subgraph centralities for each node of the
network.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary adjacency matrix</p>
</div></blockquote>
<p><strong>Cs</strong> : Nx1 np.ndarray</p>
<blockquote class="last">
<div><p>subgraph centrality</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="clustering">
<h2>Clustering<a class="headerlink" href="#clustering" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="bct.agreement">
<tt class="descclassname">bct.</tt><tt class="descname">agreement</tt><big>(</big><em>ci</em>, <em>buffsz=None</em><big>)</big><a class="headerlink" href="#bct.agreement" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes as input a set of vertex partitions CI of
dimensions [vertex x partition]. Each column in CI contains the
assignments of each vertex to a class/community/module. This function
aggregates the partitions in CI into a square [vertex x vertex]
agreement matrix D, whose elements indicate the number of times any two
vertices were assigned to the same class.</p>
<p>In the case that the number of nodes and partitions in CI is large
(greater than ~1000 nodes or greater than ~1000 partitions), the script
can be made faster by computing D in pieces. The optional input BUFFSZ
determines the size of each piece. Trial and error has found that
BUFFSZ ~ 150 works well.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ci</strong> : MxN np.ndarray</p>
<blockquote>
<div><p>set of M (possibly degenerate) partitions of N nodes</p>
</div></blockquote>
<p><strong>buffsz</strong> : int | None</p>
<blockquote>
<div><p>sets buffer size. If not specified, defaults to 1000</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>D</strong> : NxN np.ndarray</p>
<blockquote class="last">
<div><p>agreement matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.agreement_weighted">
<tt class="descclassname">bct.</tt><tt class="descname">agreement_weighted</tt><big>(</big><em>ci</em>, <em>wts</em><big>)</big><a class="headerlink" href="#bct.agreement_weighted" title="Permalink to this definition">¶</a></dt>
<dd><p>D = AGREEMENT_WEIGHTED(CI,WTS) is identical to AGREEMENT, with the
exception that each partitions contribution is weighted according to
the corresponding scalar value stored in the vector WTS. As an example,
suppose CI contained partitions obtained using some heuristic for
maximizing modularity. A possible choice for WTS might be the Q metric
(Newman&#8217;s modularity score). Such a choice would add more weight to
higher modularity partitions.</p>
<p>NOTE: Unlike AGREEMENT, this script does not have the input argument
BUFFSZ.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ci</strong> : MxN np.ndarray</p>
<blockquote>
<div><p>set of M (possibly degenerate) partitions of N nodes</p>
</div></blockquote>
<p><strong>wts</strong> : Mx1 np.ndarray</p>
<blockquote>
<div><p>relative weight of each partition</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>D</strong> : NxN np.ndarray</p>
<blockquote class="last">
<div><p>weighted agreement matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.clustering_coef_bd">
<tt class="descclassname">bct.</tt><tt class="descname">clustering_coef_bd</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#bct.clustering_coef_bd" title="Permalink to this definition">¶</a></dt>
<dd><p>The clustering coefficient is the fraction of triangles around a node
(equiv. the fraction of nodes neighbors that are neighbors of each other).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary directed connection matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>C</strong> : Nx1 np.ndarray</p>
<blockquote class="last">
<div><p>clustering coefficient vector</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Methodological note: In directed graphs, 3 nodes generate up to 8
triangles (2*2*2 edges). The number of existing triangles is the main
diagonal of S^3/2. The number of all (in or out) neighbour pairs is
K(K-1)/2. Each neighbour pair may generate two triangles. &#8220;False pairs&#8221;
are i&lt;-&gt;j edge pairs (these do not generate triangles). The number of
false pairs is the main diagonal of A^2.
Thus the maximum possible number of triangles =</p>
<blockquote>
<div>= (2 edges)*([ALL PAIRS] - [FALSE PAIRS])
= 2 * (K(K-1)/2 - diag(A^2))
= K(K-1) - 2(diag(A^2))</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="bct.clustering_coef_bu">
<tt class="descclassname">bct.</tt><tt class="descname">clustering_coef_bu</tt><big>(</big><em>G</em><big>)</big><a class="headerlink" href="#bct.clustering_coef_bu" title="Permalink to this definition">¶</a></dt>
<dd><p>The clustering coefficient is the fraction of triangles around a node
(equiv. the fraction of nodes neighbors that are neighbors of each other).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary undirected connection matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>C</strong> : Nx1 np.ndarray</p>
<blockquote class="last">
<div><p>clustering coefficient vector</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.clustering_coef_wd">
<tt class="descclassname">bct.</tt><tt class="descname">clustering_coef_wd</tt><big>(</big><em>W</em><big>)</big><a class="headerlink" href="#bct.clustering_coef_wd" title="Permalink to this definition">¶</a></dt>
<dd><p>The weighted clustering coefficient is the average &#8220;intensity&#8221; of
triangles around a node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>weighted directed connection matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>C</strong> : Nx1 np.ndarray</p>
<blockquote class="last">
<div><p>clustering coefficient vector</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Methodological note (also see clustering_coef_bd)
The weighted modification is as follows:
- The numerator: adjacency matrix is replaced with weights matrix ^ 1/3
- The denominator: no changes from the binary version</p>
<p>The above reduces to symmetric and/or binary versions of the clustering
coefficient for respective graphs.</p>
</dd></dl>

<dl class="function">
<dt id="bct.clustering_coef_wu">
<tt class="descclassname">bct.</tt><tt class="descname">clustering_coef_wu</tt><big>(</big><em>W</em><big>)</big><a class="headerlink" href="#bct.clustering_coef_wu" title="Permalink to this definition">¶</a></dt>
<dd><p>The weighted clustering coefficient is the average &#8220;intensity&#8221; of
triangles around a node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>weighted undirected connection matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>C</strong> : Nx1 np.ndarray</p>
<blockquote class="last">
<div><p>clustering coefficient vector</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.consensus_und">
<tt class="descclassname">bct.</tt><tt class="descname">consensus_und</tt><big>(</big><em>D</em>, <em>tau</em>, <em>reps=1000</em><big>)</big><a class="headerlink" href="#bct.consensus_und" title="Permalink to this definition">¶</a></dt>
<dd><p>This algorithm seeks a consensus partition of the
agreement matrix D. The algorithm used here is almost identical to the
one introduced in Lancichinetti &amp; Fortunato (2012): The agreement
matrix D is thresholded at a level TAU to remove an weak elements. The
resulting matrix is then partitions REPS number of times using the
Louvain algorithm (in principle, any clustering algorithm that can
handle weighted matrixes is a suitable alternative to the Louvain
algorithm and can be substituted in its place). This clustering
produces a set of partitions from which a new agreement is built. If
the partitions have not converged to a single representative partition,
the above process repeats itself, starting with the newly built
agreement matrix.</p>
<p>NOTE: In this implementation, the elements of the agreement matrix must
be converted into probabilities.</p>
<p>NOTE: This implementation is slightly different from the original
algorithm proposed by Lanchichinetti &amp; Fortunato. In its original
version, if the thresholding produces singleton communities, those
nodes are reconnected to the network. Here, we leave any singleton
communities disconnected.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>D</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>agreement matrix with entries between 0 and 1 denoting the probability
of finding node i in the same cluster as node j</p>
</div></blockquote>
<p><strong>tau</strong> : float</p>
<blockquote>
<div><p>threshold which controls the resolution of the reclustering</p>
</div></blockquote>
<p><strong>reps</strong> : int</p>
<blockquote>
<div><p>number of times the clustering algorithm is reapplied. default value
is 1000.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ciu</strong> : Nx1 np.ndarray</p>
<blockquote class="last">
<div><p>consensus partition</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.get_components">
<tt class="descclassname">bct.</tt><tt class="descname">get_components</tt><big>(</big><em>A</em>, <em>no_depend=False</em><big>)</big><a class="headerlink" href="#bct.get_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the components of an undirected graph specified by the binary and
undirected adjacency matrix adj. Components and their constitutent nodes
are assigned the same index and stored in the vector, comps. The vector,
comp_sizes, contains the number of nodes beloning to each component.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary undirected adjacency matrix</p>
</div></blockquote>
<p><strong>no_depend</strong> : Any</p>
<blockquote>
<div><p>Does nothing, included for backwards compatibility</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>comps</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>vector of component assignments for each node</p>
</div></blockquote>
<p><strong>comp_sizes</strong> : Mx1 np.ndarray</p>
<blockquote class="last">
<div><p>vector of component sizes</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Note: disconnected nodes will appear as components with a component
size of 1</p>
<p>Note: The identity of each component (i.e. its numerical value in the
result) is not guaranteed to be identical the value returned in BCT,
matlab code, although the component topology is.</p>
<p>Many thanks to Nick Cullen for providing this implementation</p>
</dd></dl>

<dl class="function">
<dt id="bct.transitivity_bd">
<tt class="descclassname">bct.</tt><tt class="descname">transitivity_bd</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#bct.transitivity_bd" title="Permalink to this definition">¶</a></dt>
<dd><p>Transitivity is the ratio of &#8216;triangles to triplets&#8217; in the network.
(A classical version of the clustering coefficient).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary directed connection matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>T</strong> : float</p>
<blockquote class="last">
<div><p>transitivity scalar</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Methodological note: In directed graphs, 3 nodes generate up to 8
triangles (2*2*2 edges). The number of existing triangles is the main</p>
<p>diagonal of S^3/2. The number of all (in or out) neighbour pairs is
K(K-1)/2. Each neighbour pair may generate two triangles. &#8220;False pairs&#8221;
are i&lt;-&gt;j edge pairs (these do not generate triangles). The number of
false pairs is the main diagonal of A^2. Thus the maximum possible
number of triangles = (2 edges)*([ALL PAIRS] - [FALSE PAIRS])</p>
<blockquote>
<div>= 2 * (K(K-1)/2 - diag(A^2))
= K(K-1) - 2(diag(A^2))</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="bct.transitivity_bu">
<tt class="descclassname">bct.</tt><tt class="descname">transitivity_bu</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#bct.transitivity_bu" title="Permalink to this definition">¶</a></dt>
<dd><p>Transitivity is the ratio of &#8216;triangles to triplets&#8217; in the network.
(A classical version of the clustering coefficient).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary undirected connection matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>T</strong> : float</p>
<blockquote class="last">
<div><p>transitivity scalar</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.transitivity_wd">
<tt class="descclassname">bct.</tt><tt class="descname">transitivity_wd</tt><big>(</big><em>W</em><big>)</big><a class="headerlink" href="#bct.transitivity_wd" title="Permalink to this definition">¶</a></dt>
<dd><p>Transitivity is the ratio of &#8216;triangles to triplets&#8217; in the network.
(A classical version of the clustering coefficient).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>weighted directed connection matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>T</strong> : int</p>
<blockquote>
<div><p>transitivity scalar</p>
</div></blockquote>
<p><strong>Methodological note (also see note for clustering_coef_bd)</strong> :</p>
<p><strong>The weighted modification is as follows:</strong> :</p>
<p><strong>- The numerator: adjacency matrix is replaced with weights matrix ^ 1/3</strong> :</p>
<p><strong>- The denominator: no changes from the binary version</strong> :</p>
<p><strong>The above reduces to symmetric and/or binary versions of the clustering</strong> :</p>
<p class="last"><strong>coefficient for respective graphs.</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.transitivity_wu">
<tt class="descclassname">bct.</tt><tt class="descname">transitivity_wu</tt><big>(</big><em>W</em><big>)</big><a class="headerlink" href="#bct.transitivity_wu" title="Permalink to this definition">¶</a></dt>
<dd><p>Transitivity is the ratio of &#8216;triangles to triplets&#8217; in the network.
(A classical version of the clustering coefficient).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>weighted undirected connection matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>T</strong> : int</p>
<blockquote class="last">
<div><p>transitivity scalar</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="core">
<h2>Core<a class="headerlink" href="#core" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="bct.assortativity_bin">
<tt class="descclassname">bct.</tt><tt class="descname">assortativity_bin</tt><big>(</big><em>CIJ</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#bct.assortativity_bin" title="Permalink to this definition">¶</a></dt>
<dd><p>The assortativity coefficient is a correlation coefficient between the
degrees of all nodes on two opposite ends of a link. A positive
assortativity coefficient indicates that nodes tend to link to other
nodes with the same or similar degree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary directed/undirected connection matrix</p>
</div></blockquote>
<p><strong>flag</strong> : int</p>
<blockquote>
<div><p>0 : undirected graph; degree/degree correlation
1 : directed graph; out-degree/in-degree correlation
2 : directed graph; in-degree/out-degree correlation
3 : directed graph; out-degree/out-degree correlation
4 : directed graph; in-degree/in-degreen correlation</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>r</strong> : float</p>
<blockquote class="last">
<div><p>assortativity coefficient</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The function accepts weighted networks, but all connection
weights are ignored. The main diagonal should be empty. For flag 1
the function computes the directed assortativity described in Rubinov
and Sporns (2010) NeuroImage.</p>
</dd></dl>

<dl class="function">
<dt id="bct.assortativity_wei">
<tt class="descclassname">bct.</tt><tt class="descname">assortativity_wei</tt><big>(</big><em>CIJ</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#bct.assortativity_wei" title="Permalink to this definition">¶</a></dt>
<dd><p>The assortativity coefficient is a correlation coefficient between the
strengths (weighted degrees) of all nodes on two opposite ends of a link.
A positive assortativity coefficient indicates that nodes tend to link to
other nodes with the same or similar strength.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>weighted directed/undirected connection matrix</p>
</div></blockquote>
<p><strong>flag</strong> : int</p>
<blockquote>
<div><p>0 : undirected graph; strength/strength correlation
1 : directed graph; out-strength/in-strength correlation
2 : directed graph; in-strength/out-strength correlation
3 : directed graph; out-strength/out-strength correlation
4 : directed graph; in-strength/in-strengthn correlation</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>r</strong> : float</p>
<blockquote class="last">
<div><p>assortativity coefficient</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<dl class="docutils">
<dt>The main diagonal should be empty. For flag 1</dt>
<dd>the function computes the directed assortativity described in Rubinov
and Sporns (2010) NeuroImage.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.kcore_bd">
<tt class="descclassname">bct.</tt><tt class="descname">kcore_bd</tt><big>(</big><em>CIJ</em>, <em>k</em>, <em>peel=False</em><big>)</big><a class="headerlink" href="#bct.kcore_bd" title="Permalink to this definition">¶</a></dt>
<dd><p>The k-core is the largest subnetwork comprising nodes of degree at
least k. This function computes the k-core for a given binary directed
connection matrix by recursively peeling off nodes with degree lower
than k, until no such nodes remain.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary directed adjacency matrix</p>
</div></blockquote>
<p><strong>k</strong> : int</p>
<blockquote>
<div><p>level of k-core</p>
</div></blockquote>
<p><strong>peel</strong> : bool</p>
<blockquote>
<div><p>If True, additionally calculates peelorder and peellevel. Defaults to
False.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>CIJkcore</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>connection matrix of the k-core. This matrix only contains nodes of
degree at least k.</p>
</div></blockquote>
<p><strong>kn</strong> : int</p>
<blockquote>
<div><p>size of k-core</p>
</div></blockquote>
<p><strong>peelorder</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>indices in the order in which they were peeled away during k-core
decomposition. only returned if peel is specified.</p>
</div></blockquote>
<p><strong>peellevel</strong> : Nx1 np.ndarray</p>
<blockquote class="last">
<div><p>corresponding level - nodes in at the same level have been peeled
away at the same time. only return if peel is specified</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>&#8216;peelorder&#8217; and &#8216;peellevel&#8217; are similar the the k-core sub-shells
described in Modha and Singh (2010).</p>
</dd></dl>

<dl class="function">
<dt id="bct.kcore_bu">
<tt class="descclassname">bct.</tt><tt class="descname">kcore_bu</tt><big>(</big><em>CIJ</em>, <em>k</em>, <em>peel=False</em><big>)</big><a class="headerlink" href="#bct.kcore_bu" title="Permalink to this definition">¶</a></dt>
<dd><p>The k-core is the largest subnetwork comprising nodes of degree at
least k. This function computes the k-core for a given binary
undirected connection matrix by recursively peeling off nodes with
degree lower than k, until no such nodes remain.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary undirected connection matrix</p>
</div></blockquote>
<p><strong>k</strong> : int</p>
<blockquote>
<div><p>level of k-core</p>
</div></blockquote>
<p><strong>peel</strong> : bool</p>
<blockquote>
<div><p>If True, additionally calculates peelorder and peellevel. Defaults to
False.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>CIJkcore</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>connection matrix of the k-core. This matrix only contains nodes of
degree at least k.</p>
</div></blockquote>
<p><strong>kn</strong> : int</p>
<blockquote>
<div><p>size of k-core</p>
</div></blockquote>
<p><strong>peelorder</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>indices in the order in which they were peeled away during k-core
decomposition. only returned if peel is specified.</p>
</div></blockquote>
<p><strong>peellevel</strong> : Nx1 np.ndarray</p>
<blockquote class="last">
<div><p>corresponding level - nodes in at the same level have been peeled
away at the same time. only return if peel is specified</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>&#8216;peelorder&#8217; and &#8216;peellevel&#8217; are similar the the k-core sub-shells
described in Modha and Singh (2010).</p>
</dd></dl>

<dl class="function">
<dt id="bct.rich_club_bd">
<tt class="descclassname">bct.</tt><tt class="descname">rich_club_bd</tt><big>(</big><em>CIJ</em>, <em>klevel=None</em><big>)</big><a class="headerlink" href="#bct.rich_club_bd" title="Permalink to this definition">¶</a></dt>
<dd><p>The rich club coefficient, R, at level k is the fraction of edges that
connect nodes of degree k or higher out of the maximum number of edges
that such nodes might share.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary directed connection matrix</p>
</div></blockquote>
<p><strong>klevel</strong> : int | None</p>
<blockquote>
<div><p>sets the maximum level at which the rich club coefficient will be
calculated. If None (default), the maximum level is set to the
maximum degree of the adjacency matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>R</strong> : Kx1 np.ndarray</p>
<blockquote>
<div><p>vector of rich-club coefficients for levels 1 to klevel</p>
</div></blockquote>
<p><strong>Nk</strong> : int</p>
<blockquote>
<div><p>number of nodes with degree &gt; k</p>
</div></blockquote>
<p><strong>Ek</strong> : int</p>
<blockquote class="last">
<div><p>number of edges remaining in subgraph with degree &gt; k</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.rich_club_bu">
<tt class="descclassname">bct.</tt><tt class="descname">rich_club_bu</tt><big>(</big><em>CIJ</em>, <em>klevel=None</em><big>)</big><a class="headerlink" href="#bct.rich_club_bu" title="Permalink to this definition">¶</a></dt>
<dd><p>The rich club coefficient, R, at level k is the fraction of edges that
connect nodes of degree k or higher out of the maximum number of edges
that such nodes might share.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary undirected connection matrix</p>
</div></blockquote>
<p><strong>klevel</strong> : int | None</p>
<blockquote>
<div><p>sets the maximum level at which the rich club coefficient will be
calculated. If None (default), the maximum level is set to the
maximum degree of the adjacency matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>R</strong> : Kx1 np.ndarray</p>
<blockquote>
<div><p>vector of rich-club coefficients for levels 1 to klevel</p>
</div></blockquote>
<p><strong>Nk</strong> : int</p>
<blockquote>
<div><p>number of nodes with degree &gt; k</p>
</div></blockquote>
<p><strong>Ek</strong> : int</p>
<blockquote class="last">
<div><p>number of edges remaining in subgraph with degree &gt; k</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.rich_club_wd">
<tt class="descclassname">bct.</tt><tt class="descname">rich_club_wd</tt><big>(</big><em>CIJ</em>, <em>klevel=None</em><big>)</big><a class="headerlink" href="#bct.rich_club_wd" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>weighted directed connection matrix</p>
</div></blockquote>
<p><strong>klevel</strong> : int | None</p>
<blockquote>
<div><p>sets the maximum level at which the rich club coefficient will be
calculated. If None (default), the maximum level is set to the
maximum degree of the adjacency matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Rw</strong> : Kx1 np.ndarray</p>
<blockquote class="last">
<div><p>vector of rich-club coefficients for levels 1 to klevel</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.rich_club_wu">
<tt class="descclassname">bct.</tt><tt class="descname">rich_club_wu</tt><big>(</big><em>CIJ</em>, <em>klevel=None</em><big>)</big><a class="headerlink" href="#bct.rich_club_wu" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>weighted undirected connection matrix</p>
</div></blockquote>
<p><strong>klevel</strong> : int | None</p>
<blockquote>
<div><p>sets the maximum level at which the rich club coefficient will be
calculated. If None (default), the maximum level is set to the
maximum degree of the adjacency matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Rw</strong> : Kx1 np.ndarray</p>
<blockquote class="last">
<div><p>vector of rich-club coefficients for levels 1 to klevel</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.score_wu">
<tt class="descclassname">bct.</tt><tt class="descname">score_wu</tt><big>(</big><em>CIJ</em>, <em>s</em><big>)</big><a class="headerlink" href="#bct.score_wu" title="Permalink to this definition">¶</a></dt>
<dd><p>The s-core is the largest subnetwork comprising nodes of strength at
least s. This function computes the s-core for a given weighted
undirected connection matrix. Computation is analogous to the more
widely used k-core, but is based on node strengths instead of node
degrees.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>weighted undirected connection matrix</p>
</div></blockquote>
<p><strong>s</strong> : float</p>
<blockquote>
<div><p>level of s-core. Note that can take on any fractional value.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>CIJscore</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>connection matrix of the s-core. This matrix contains only nodes with
a strength of at least s.</p>
</div></blockquote>
<p><strong>sn</strong> : int</p>
<blockquote class="last">
<div><p>size of s-core</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="degree">
<h2>Degree<a class="headerlink" href="#degree" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="bct.degrees_dir">
<tt class="descclassname">bct.</tt><tt class="descname">degrees_dir</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.degrees_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Node degree is the number of links connected to the node. The indegree
is the number of inward links and the outdegree is the number of
outward links.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>directed binary/weighted connection matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>id</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>node in-degree</p>
</div></blockquote>
<p><strong>od</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>node out-degree</p>
</div></blockquote>
<p><strong>deg</strong> : Nx1 np.ndarray</p>
<blockquote class="last">
<div><p>node degree (in-degree + out-degree)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<dl class="docutils">
<dt>Inputs are assumed to be on the columns of the CIJ matrix.</dt>
<dd>Weight information is discarded.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.degrees_und">
<tt class="descclassname">bct.</tt><tt class="descname">degrees_und</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.degrees_und" title="Permalink to this definition">¶</a></dt>
<dd><p>Node degree is the number of links connected to the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>undirected binary/weighted connection matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>deg</strong> : Nx1 np.ndarray</p>
<blockquote class="last">
<div><p>node degree</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Weight information is discarded.</p>
</dd></dl>

<dl class="function">
<dt id="bct.jdegree">
<tt class="descclassname">bct.</tt><tt class="descname">jdegree</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.jdegree" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns a matrix in which the value of each element (u,v)
corresponds to the number of nodes that have u outgoing connections
and v incoming connections.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>directed binary/weighted connnection matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>J</strong> : ZxZ np.ndarray</p>
<blockquote>
<div><p>joint degree distribution matrix
(shifted by one, replicates matlab one-based-indexing)</p>
</div></blockquote>
<p><strong>J_od</strong> : int</p>
<blockquote>
<div><p>number of vertices with od&gt;id</p>
</div></blockquote>
<p><strong>J_id</strong> : int</p>
<blockquote>
<div><p>number of vertices with id&gt;od</p>
</div></blockquote>
<p><strong>J_bl</strong> : int</p>
<blockquote class="last">
<div><p>number of vertices with id==od</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Weights are discarded.</p>
</dd></dl>

<dl class="function">
<dt id="bct.strengths_dir">
<tt class="descclassname">bct.</tt><tt class="descname">strengths_dir</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.strengths_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Node strength is the sum of weights of links connected to the node. The
instrength is the sum of inward link weights and the outstrength is the
sum of outward link weights.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>directed weighted connection matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>is</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>node in-strength</p>
</div></blockquote>
<p><strong>os</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>node out-strength</p>
</div></blockquote>
<p><strong>str</strong> : Nx1 np.ndarray</p>
<blockquote class="last">
<div><p>node strength (in-strength + out-strength)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Inputs are assumed to be on the columns of the CIJ matrix.</p>
</dd></dl>

<dl class="function">
<dt id="bct.strengths_und">
<tt class="descclassname">bct.</tt><tt class="descname">strengths_und</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.strengths_und" title="Permalink to this definition">¶</a></dt>
<dd><p>Node strength is the sum of weights of links connected to the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>undirected weighted connection matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>str</strong> : Nx1 np.ndarray</p>
<blockquote class="last">
<div><p>node strengths</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.strengths_und_sign">
<tt class="descclassname">bct.</tt><tt class="descname">strengths_und_sign</tt><big>(</big><em>W</em><big>)</big><a class="headerlink" href="#bct.strengths_und_sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Node strength is the sum of weights of links connected to the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>undirected connection matrix with positive and negative weights</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Spos</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>nodal strength of positive weights</p>
</div></blockquote>
<p><strong>Sneg</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>nodal strength of positive weights</p>
</div></blockquote>
<p><strong>vpos</strong> : float</p>
<blockquote>
<div><p>total positive weight</p>
</div></blockquote>
<p><strong>vneg</strong> : float</p>
<blockquote class="last">
<div><p>total negative weight</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="distance">
<h2>Distance<a class="headerlink" href="#distance" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="bct.breadthdist">
<tt class="descclassname">bct.</tt><tt class="descname">breadthdist</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.breadthdist" title="Permalink to this definition">¶</a></dt>
<dd><p>The binary reachability matrix describes reachability between all pairs
of nodes. An entry (u,v)=1 means that there exists a path from node u
to node v; alternatively (u,v)=0.</p>
<p>The distance matrix contains lengths of shortest paths between all
pairs of nodes. An entry (u,v) represents the length of shortest path
from node u to  node v. The average shortest path length is the
characteristic path length of the network.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary directed/undirected connection matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>R</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary reachability matrix</p>
</div></blockquote>
<p><strong>D</strong> : NxN np.ndarray</p>
<blockquote class="last">
<div><p>distance matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>slower but less memory intensive than &#8220;reachdist.m&#8221;.</p>
</dd></dl>

<dl class="function">
<dt id="bct.breadth">
<tt class="descclassname">bct.</tt><tt class="descname">breadth</tt><big>(</big><em>CIJ</em>, <em>source</em><big>)</big><a class="headerlink" href="#bct.breadth" title="Permalink to this definition">¶</a></dt>
<dd><p>Implementation of breadth-first search.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary directed/undirected connection matrix</p>
</div></blockquote>
<p><strong>source</strong> : int</p>
<blockquote>
<div><p>source vertex</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>distance</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>vector of distances between source and ith vertex (0 for source)</p>
</div></blockquote>
<p><strong>branch</strong> : Nx1 np.ndarray</p>
<blockquote class="last">
<div><p>vertex that precedes i in the breadth-first search (-1 for source)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Breadth-first search tree does not contain all paths (or all
shortest paths), but allows the determination of at least one path with
minimum distance. The entire graph is explored, starting from source
vertex &#8216;source&#8217;.</p>
</dd></dl>

<dl class="function">
<dt id="bct.charpath">
<tt class="descclassname">bct.</tt><tt class="descname">charpath</tt><big>(</big><em>D</em>, <em>include_diagonal=False</em>, <em>include_infinite=True</em><big>)</big><a class="headerlink" href="#bct.charpath" title="Permalink to this definition">¶</a></dt>
<dd><p>The characteristic path length is the average shortest path length in
the network. The global efficiency is the average inverse shortest path
length in the network.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>D</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>distance matrix</p>
</div></blockquote>
<p><strong>include_diagonal</strong> : bool</p>
<blockquote>
<div><p>If True, include the weights on the diagonal. Default value is False.</p>
</div></blockquote>
<p><strong>include_infinite</strong> : bool</p>
<blockquote>
<div><p>If True, include infinite distances in calculation</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>lambda</strong> : float</p>
<blockquote>
<div><p>characteristic path length</p>
</div></blockquote>
<p><strong>efficiency</strong> : float</p>
<blockquote>
<div><p>global efficiency</p>
</div></blockquote>
<p><strong>ecc</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>eccentricity at each vertex</p>
</div></blockquote>
<p><strong>radius</strong> : float</p>
<blockquote>
<div><p>radius of graph</p>
</div></blockquote>
<p><strong>diameter</strong> : float</p>
<blockquote class="last">
<div><p>diameter of graph</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The input distance matrix may be obtained with any of the distance
functions, e.g. distance_bin, distance_wei.
Characteristic path length is calculated as the global mean of
the distance matrix D, excludings any &#8216;Infs&#8217; but including distances on
the main diagonal.</p>
</dd></dl>

<dl class="function">
<dt id="bct.cycprob">
<tt class="descclassname">bct.</tt><tt class="descname">cycprob</tt><big>(</big><em>Pq</em><big>)</big><a class="headerlink" href="#bct.cycprob" title="Permalink to this definition">¶</a></dt>
<dd><p>Cycles are paths which begin and end at the same node. Cycle
probability for path length d, is the fraction of all paths of length
d-1 that may be extended to form cycles of length d.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Pq</strong> : NxNxQ np.ndarray</p>
<blockquote>
<div><p>Path matrix with Pq[i,j,q] = number of paths from i to j of length q.
Produced by findpaths()</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fcyc</strong> : Qx1 np.ndarray</p>
<blockquote>
<div><p>fraction of all paths that are cycles for each path length q</p>
</div></blockquote>
<p><strong>pcyc</strong> : Qx1 np.ndarray</p>
<blockquote class="last">
<div><p>probability that a non-cyclic path of length q-1 can be extended to
form a cycle of length q for each path length q</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.distance_bin">
<tt class="descclassname">bct.</tt><tt class="descname">distance_bin</tt><big>(</big><em>G</em><big>)</big><a class="headerlink" href="#bct.distance_bin" title="Permalink to this definition">¶</a></dt>
<dd><p>The distance matrix contains lengths of shortest paths between all
pairs of nodes. An entry (u,v) represents the length of shortest path
from node u to node v. The average shortest path length is the
characteristic path length of the network.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary directed/undirected connection matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>D</strong> : NxN</p>
<blockquote class="last">
<div><p>distance matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Lengths between disconnected nodes are set to Inf.
Lengths on the main diagonal are set to 0.
Algorithm: Algebraic shortest paths.</p>
</dd></dl>

<dl class="function">
<dt id="bct.distance_wei">
<tt class="descclassname">bct.</tt><tt class="descname">distance_wei</tt><big>(</big><em>G</em><big>)</big><a class="headerlink" href="#bct.distance_wei" title="Permalink to this definition">¶</a></dt>
<dd><p>The distance matrix contains lengths of shortest paths between all
pairs of nodes. An entry (u,v) represents the length of shortest path
from node u to node v. The average shortest path length is the
characteristic path length of the network.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>L</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>Directed/undirected connection-length matrix.
NB L is not the adjacency matrix. See below.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>D</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>distance (shortest weighted path) matrix</p>
</div></blockquote>
<p><strong>B</strong> : NxN np.ndarray</p>
<blockquote class="last">
<div><p>matrix of number of edges in shortest weighted path</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p>obtained via a mapping from weight to length. For instance, in a
weighted correlation network higher correlations are more naturally
interpreted as shorter distances and the input matrix should
consequently be some inverse of the connectivity matrix.</p>
<blockquote>
<div>The number of edges in shortest weighted paths may in general</div></blockquote>
<p>exceed the number of edges in shortest binary paths (i.e. shortest
paths computed on the binarized connectivity matrix), because shortest
weighted paths have the minimal weighted distance, but not necessarily
the minimal number of edges.</p>
<blockquote>
<div>Lengths between disconnected nodes are set to Inf.
Lengths on the main diagonal are set to 0.</div></blockquote>
<p>Algorithm: Dijkstra&#8217;s algorithm.</p>
</dd></dl>

<dl class="function">
<dt id="bct.efficiency_bin">
<tt class="descclassname">bct.</tt><tt class="descname">efficiency_bin</tt><big>(</big><em>G</em>, <em>local=False</em><big>)</big><a class="headerlink" href="#bct.efficiency_bin" title="Permalink to this definition">¶</a></dt>
<dd><p>The global efficiency is the average of inverse shortest path length,
and is inversely related to the characteristic path length.</p>
<p>The local efficiency is the global efficiency computed on the
neighborhood of the node, and is related to the clustering coefficient.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary undirected connection matrix</p>
</div></blockquote>
<p><strong>local</strong> : bool</p>
<blockquote>
<div><p>If True, computes local efficiency instead of global efficiency.
Default value = False.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Eglob</strong> : float</p>
<blockquote>
<div><p>global efficiency, only if local=False</p>
</div></blockquote>
<p><strong>Eloc</strong> : Nx1 np.ndarray</p>
<blockquote class="last">
<div><p>local efficiency, only if local=True</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.efficiency_wei">
<tt class="descclassname">bct.</tt><tt class="descname">efficiency_wei</tt><big>(</big><em>Gw</em>, <em>local=False</em><big>)</big><a class="headerlink" href="#bct.efficiency_wei" title="Permalink to this definition">¶</a></dt>
<dd><p>The global efficiency is the average of inverse shortest path length,
and is inversely related to the characteristic path length.</p>
<p>The local efficiency is the global efficiency computed on the
neighborhood of the node, and is related to the clustering coefficient.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>undirected weighted connection matrix
(all weights in W must be between 0 and 1)</p>
</div></blockquote>
<p><strong>local</strong> : bool</p>
<blockquote>
<div><p>If True, computes local efficiency instead of global efficiency.
Default value = False.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Eglob</strong> : float</p>
<blockquote>
<div><p>global efficiency, only if local=False</p>
</div></blockquote>
<p><strong>Eloc</strong> : Nx1 np.ndarray</p>
<blockquote class="last">
<div><p>local efficiency, only if local=True</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p>matrix L, defined as L_ij = 1/W_ij for all nonzero L_ij; This has an
intuitive interpretation, as higher connection weights intuitively
correspond to shorter lengths.</p>
<blockquote>
<div>The weighted local efficiency broadly parallels the weighted</div></blockquote>
<p>clustering coefficient of Onnela et al. (2005) and distinguishes the
influence of different paths based on connection weights of the
corresponding neighbors to the node in question. In other words, a path
between two neighbors with strong connections to the node in question
contributes more to the local efficiency than a path between two weakly
connected neighbors. Note that this weighted variant of the local
efficiency is hence not a strict generalization of the binary variant.</p>
<p>Algorithm:  Dijkstra&#8217;s algorithm</p>
</dd></dl>

<dl class="function">
<dt id="bct.findpaths">
<tt class="descclassname">bct.</tt><tt class="descname">findpaths</tt><big>(</big><em>CIJ</em>, <em>qmax</em>, <em>sources</em>, <em>savepths=False</em><big>)</big><a class="headerlink" href="#bct.findpaths" title="Permalink to this definition">¶</a></dt>
<dd><p>Paths are sequences of linked nodes, that never visit a single node
more than once. This function finds all paths that start at a set of
source nodes, up to a specified length. Warning: very memory-intensive.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary directed/undirected connection matrix</p>
</div></blockquote>
<p><strong>qmax</strong> : int</p>
<blockquote>
<div><p>maximal path length</p>
</div></blockquote>
<p><strong>sources</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>source units from which paths are grown</p>
</div></blockquote>
<p><strong>savepths</strong> : bool</p>
<blockquote>
<div><p>True if all paths are to be collected and returned. This functionality
is currently not enabled.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Pq</strong> : NxNxQ np.ndarray</p>
<blockquote>
<div><p>Path matrix with P[i,j,jq] = number of paths from i to j with length q</p>
</div></blockquote>
<p><strong>tpath</strong> : int</p>
<blockquote>
<div><p>total number of paths found</p>
</div></blockquote>
<p><strong>plq</strong> : Qx1 np.ndarray</p>
<blockquote>
<div><p>path length distribution as a function of q</p>
</div></blockquote>
<p><strong>qstop</strong> : int</p>
<blockquote>
<div><p>path length at which findpaths is stopped</p>
</div></blockquote>
<p><strong>allpths</strong> : None</p>
<blockquote>
<div><p>a matrix containing all paths up to qmax. This function is extremely
complicated and reimplementing it in bctpy is not straightforward.</p>
</div></blockquote>
<p><strong>util</strong> : NxQ np.ndarray</p>
<blockquote class="last">
<div><p>node use index</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Note that Pq(:,:,N) can only carry entries on the diagonal, as all
&#8220;legal&#8221; paths of length N-1 must terminate.  Cycles of length N are
possible, with all vertices visited exactly once (except for source and
target). &#8216;qmax = N&#8217; can wreak havoc (due to memory problems).</p>
<p>Note: Weights are discarded.
Note: I am certain that this algorithm is rather inefficient -
suggestions for improvements are welcome.</p>
</dd></dl>

<dl class="function">
<dt id="bct.findwalks">
<tt class="descclassname">bct.</tt><tt class="descname">findwalks</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.findwalks" title="Permalink to this definition">¶</a></dt>
<dd><p>Walks are sequences of linked nodes, that may visit a single node more
than once. This function finds the number of walks of a given length,
between any two nodes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary directed/undirected connection matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Wq</strong> : NxNxQ np.ndarray</p>
<blockquote>
<div><p>Wq[i,j,q] is the number of walks from i to j of length q</p>
</div></blockquote>
<p><strong>twalk</strong> : int</p>
<blockquote>
<div><p>total number of walks found</p>
</div></blockquote>
<p><strong>wlq</strong> : Qx1 np.ndarray</p>
<blockquote class="last">
<div><p>walk length distribution as a function of q</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Wq grows very quickly for larger N,K,q. Weights are discarded.</p>
</dd></dl>

<dl class="function">
<dt id="bct.reachdist">
<tt class="descclassname">bct.</tt><tt class="descname">reachdist</tt><big>(</big><em>CIJ</em>, <em>ensure_binary=True</em><big>)</big><a class="headerlink" href="#bct.reachdist" title="Permalink to this definition">¶</a></dt>
<dd><p>The binary reachability matrix describes reachability between all pairs
of nodes. An entry (u,v)=1 means that there exists a path from node u
to node v; alternatively (u,v)=0.</p>
<p>The distance matrix contains lengths of shortest paths between all
pairs of nodes. An entry (u,v) represents the length of shortest path
from node u to  node v. The average shortest path length is the
characteristic path length of the network.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary directed/undirected connection matrix</p>
</div></blockquote>
<p><strong>ensure_binary</strong> : bool</p>
<blockquote>
<div><p>Binarizes input. Defaults to true. No user who is not testing 
something will ever want to not use this, use distance_wei instead for 
unweighted matrices.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>R</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary reachability matrix</p>
</div></blockquote>
<p><strong>D</strong> : NxN np.ndarray</p>
<blockquote class="last">
<div><p>distance matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>faster but more memory intensive than &#8220;breadthdist.m&#8221;.</p>
</dd></dl>

</div>
<div class="section" id="modularity">
<h2>Modularity<a class="headerlink" href="#modularity" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="bct.ci2ls">
<tt class="descclassname">bct.</tt><tt class="descname">ci2ls</tt><big>(</big><em>ci</em><big>)</big><a class="headerlink" href="#bct.ci2ls" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from a community index vector to a 2D python list of modules
The list is a pure python list, not requiring numpy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ci</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>the community index vector</p>
</div></blockquote>
<p><strong>zeroindexed</strong> : bool</p>
<blockquote>
<div><p>If True, ci uses zero-indexing (lowest value is 0). Defaults to False.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ls</strong> : listof(list)</p>
<blockquote class="last">
<div><p>pure python list with lowest value zero-indexed
(regardless of zero-indexing parameter)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.ls2ci">
<tt class="descclassname">bct.</tt><tt class="descname">ls2ci</tt><big>(</big><em>ls</em>, <em>zeroindexed=False</em><big>)</big><a class="headerlink" href="#bct.ls2ci" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from a 2D python list of modules to a community index vector.
The list is a pure python list, not requiring numpy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ls</strong> : listof(list)</p>
<blockquote>
<div><p>pure python list with lowest value zero-indexed
(regardless of value of zeroindexed parameter)</p>
</div></blockquote>
<p><strong>zeroindexed</strong> : bool</p>
<blockquote>
<div><p>If True, ci uses zero-indexing (lowest value is 0). Defaults to False.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ci</strong> : Nx1 np.ndarray</p>
<blockquote class="last">
<div><p>community index vector</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.community_louvain">
<tt class="descclassname">bct.</tt><tt class="descname">community_louvain</tt><big>(</big><em>W</em>, <em>gamma=1</em>, <em>ci=None</em>, <em>B='modularity'</em>, <em>seed=None</em><big>)</big><a class="headerlink" href="#bct.community_louvain" title="Permalink to this definition">¶</a></dt>
<dd><p>The optimal community structure is a subdivision of the network into
nonoverlapping groups of nodes which maximizes the number of within-group
edges and minimizes the number of between-group edges.</p>
<p>This function is a fast an accurate multi-iterative generalization of the
louvain community detection algorithm. This function subsumes and improves
upon modularity_[louvain,finetune]_[und,dir]() and additionally allows to
optimize other objective functions (includes built-in Potts Model i
Hamiltonian, allows for custom objective-function matrices).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.array</p>
<blockquote>
<div><p>directed/undirected weighted/binary adjacency matrix</p>
</div></blockquote>
<p><strong>gamma</strong> : float</p>
<blockquote>
<div><p>resolution parameter. default value=1. Values 0 &lt;= gamma &lt; 1 detect
larger modules while gamma &gt; 1 detects smaller modules.
ignored if an objective function matrix is specified.</p>
</div></blockquote>
<p><strong>ci</strong> : Nx1 np.arraylike</p>
<blockquote>
<div><p>initial community affiliation vector. default value=None</p>
</div></blockquote>
<p><strong>B</strong> : str | NxN np.arraylike</p>
<blockquote>
<div><p>string describing objective function type, or provides a custom
objective-function matrix. builtin values &#8216;modularity&#8217; uses Q-metric
as objective function, or &#8216;potts&#8217; uses Potts model Hamiltonian.
Default value &#8216;modularity&#8217;.</p>
</div></blockquote>
<p><strong>seed</strong> : int | None</p>
<blockquote>
<div><p>random seed. default value=None. if None, seeds from /dev/urandom.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ci</strong> : Nx1 np.array</p>
<blockquote>
<div><p>final community structure</p>
</div></blockquote>
<p><strong>q</strong> : float</p>
<blockquote class="last">
<div><p>optimized q-statistic (modularity only)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.link_communities">
<tt class="descclassname">bct.</tt><tt class="descname">link_communities</tt><big>(</big><em>W</em>, <em>type_clustering='single'</em><big>)</big><a class="headerlink" href="#bct.link_communities" title="Permalink to this definition">¶</a></dt>
<dd><p>The optimal community structure is a subdivision of the network into
nonoverlapping groups of nodes which maximizes the number of within-group
edges and minimizes the number of between-group edges.</p>
<p>This algorithm uncovers overlapping community structure via hierarchical
clustering of network links. This algorithm is generalized for
weighted/directed/fully-connected networks</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.array</p>
<blockquote>
<div><p>directed weighted/binary adjacency matrix</p>
</div></blockquote>
<p><strong>type_clustering</strong> : str</p>
<blockquote>
<div><p>type of hierarchical clustering. &#8216;single&#8217; for single-linkage,
&#8216;complete&#8217; for complete-linkage. Default value=&#8217;single&#8217;</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>M</strong> : CxN np.ndarray</p>
<blockquote class="last">
<div><p>nodal community affiliation matrix.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.modularity_dir">
<tt class="descclassname">bct.</tt><tt class="descname">modularity_dir</tt><big>(</big><em>A</em>, <em>gamma=1</em>, <em>kci=None</em><big>)</big><a class="headerlink" href="#bct.modularity_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>The optimal community structure is a subdivision of the network into
nonoverlapping groups of nodes in a way that maximizes the number of
within-group edges, and minimizes the number of between-group edges.
The modularity is a statistic that quantifies the degree to which the
network may be subdivided into such clearly delineated groups.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>directed weighted/binary connection matrix</p>
</div></blockquote>
<p><strong>gamma</strong> : float</p>
<blockquote>
<div><p>resolution parameter. default value=1. Values 0 &lt;= gamma &lt; 1 detect
larger modules while gamma &gt; 1 detects smaller modules.</p>
</div></blockquote>
<p><strong>kci</strong> : Nx1 np.ndarray | None</p>
<blockquote>
<div><p>starting community structure. If specified, calculates the Q-metric
on the community structure giving, without doing any optimzation.
Otherwise, if not specified, uses a spectral modularity maximization
algorithm.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ci</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>optimized community structure</p>
</div></blockquote>
<p><strong>Q</strong> : float</p>
<blockquote class="last">
<div><p>maximized modularity metric</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This algorithm is deterministic. The matlab function bearing this
name incorrectly disclaims that the outcome depends on heuristics
involving a random seed. The louvain method does depend on a random seed,
but this function uses a deterministic modularity maximization algorithm.</p>
</dd></dl>

<dl class="function">
<dt id="bct.modularity_und">
<tt class="descclassname">bct.</tt><tt class="descname">modularity_und</tt><big>(</big><em>A</em>, <em>gamma=1</em>, <em>kci=None</em><big>)</big><a class="headerlink" href="#bct.modularity_und" title="Permalink to this definition">¶</a></dt>
<dd><p>The optimal community structure is a subdivision of the network into
nonoverlapping groups of nodes in a way that maximizes the number of
within-group edges, and minimizes the number of between-group edges.
The modularity is a statistic that quantifies the degree to which the
network may be subdivided into such clearly delineated groups.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>undirected weighted/binary connection matrix</p>
</div></blockquote>
<p><strong>gamma</strong> : float</p>
<blockquote>
<div><p>resolution parameter. default value=1. Values 0 &lt;= gamma &lt; 1 detect
larger modules while gamma &gt; 1 detects smaller modules.</p>
</div></blockquote>
<p><strong>kci</strong> : Nx1 np.ndarray | None</p>
<blockquote>
<div><p>starting community structure. If specified, calculates the Q-metric
on the community structure giving, without doing any optimzation.
Otherwise, if not specified, uses a spectral modularity maximization
algorithm.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ci</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>optimized community structure</p>
</div></blockquote>
<p><strong>Q</strong> : float</p>
<blockquote class="last">
<div><p>maximized modularity metric</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This algorithm is deterministic. The matlab function bearing this
name incorrectly disclaims that the outcome depends on heuristics
involving a random seed. The louvain method does depend on a random seed,
but this function uses a deterministic modularity maximization algorithm.</p>
</dd></dl>

<dl class="function">
<dt id="bct.modularity_finetune_und">
<tt class="descclassname">bct.</tt><tt class="descname">modularity_finetune_und</tt><big>(</big><em>W</em>, <em>ci=None</em>, <em>gamma=1</em>, <em>seed=None</em><big>)</big><a class="headerlink" href="#bct.modularity_finetune_und" title="Permalink to this definition">¶</a></dt>
<dd><p>The optimal community structure is a subdivision of the network into
nonoverlapping groups of nodes in a way that maximizes the number of
within-group edges, and minimizes the number of between-group edges.
The modularity is a statistic that quantifies the degree to which the
network may be subdivided into such clearly delineated groups.</p>
<p>This algorithm is inspired by the Kernighan-Lin fine-tuning algorithm
and is designed to refine a previously detected community structure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>undirected weighted/binary connection matrix</p>
</div></blockquote>
<p><strong>ci</strong> : Nx1 np.ndarray | None</p>
<blockquote>
<div><p>initial community affiliation vector</p>
</div></blockquote>
<p><strong>gamma</strong> : float</p>
<blockquote>
<div><p>resolution parameter. default value=1. Values 0 &lt;= gamma &lt; 1 detect
larger modules while gamma &gt; 1 detects smaller modules.</p>
</div></blockquote>
<p><strong>seed</strong> : int | None</p>
<blockquote>
<div><p>random seed. default value=None. if None, seeds from /dev/urandom.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ci</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>refined community affiliation vector</p>
</div></blockquote>
<p><strong>Q</strong> : float</p>
<blockquote class="last">
<div><p>optimized modularity metric</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Ci and Q may vary from run to run, due to heuristics in the
algorithm. Consequently, it may be worth to compare multiple runs.</p>
</dd></dl>

<dl class="function">
<dt id="bct.modularity_finetune_und_sign">
<tt class="descclassname">bct.</tt><tt class="descname">modularity_finetune_und_sign</tt><big>(</big><em>W</em>, <em>qtype='sta'</em>, <em>gamma=1</em>, <em>ci=None</em>, <em>seed=None</em><big>)</big><a class="headerlink" href="#bct.modularity_finetune_und_sign" title="Permalink to this definition">¶</a></dt>
<dd><p>The optimal community structure is a subdivision of the network into
nonoverlapping groups of nodes in a way that maximizes the number of
within-group edges, and minimizes the number of between-group edges.
The modularity is a statistic that quantifies the degree to which the
network may be subdivided into such clearly delineated groups.</p>
<p>This algorithm is inspired by the Kernighan-Lin fine-tuning algorithm
and is designed to refine a previously detected community structure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>undirected weighted/binary connection matrix with positive and
negative weights.</p>
</div></blockquote>
<p><strong>qtype</strong> : str</p>
<blockquote>
<div><p>modularity type. Can be &#8216;sta&#8217; (default), &#8216;pos&#8217;, &#8216;smp&#8217;, &#8216;gja&#8217;, &#8216;neg&#8217;.
See Rubinov and Sporns (2011) for a description.</p>
</div></blockquote>
<p><strong>gamma</strong> : float</p>
<blockquote>
<div><p>resolution parameter. default value=1. Values 0 &lt;= gamma &lt; 1 detect
larger modules while gamma &gt; 1 detects smaller modules.</p>
</div></blockquote>
<p><strong>ci</strong> : Nx1 np.ndarray | None</p>
<blockquote>
<div><p>initial community affiliation vector</p>
</div></blockquote>
<p><strong>seed</strong> : int | None</p>
<blockquote>
<div><p>random seed. default value=None. if None, seeds from /dev/urandom.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ci</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>refined community affiliation vector</p>
</div></blockquote>
<p><strong>Q</strong> : float</p>
<blockquote class="last">
<div><p>optimized modularity metric</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Ci and Q may vary from run to run, due to heuristics in the
algorithm. Consequently, it may be worth to compare multiple runs.</p>
</dd></dl>

<dl class="function">
<dt id="bct.modularity_louvain_dir">
<tt class="descclassname">bct.</tt><tt class="descname">modularity_louvain_dir</tt><big>(</big><em>W</em>, <em>gamma=1</em>, <em>hierarchy=False</em>, <em>seed=None</em><big>)</big><a class="headerlink" href="#bct.modularity_louvain_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>The optimal community structure is a subdivision of the network into
nonoverlapping groups of nodes in a way that maximizes the number of
within-group edges, and minimizes the number of between-group edges.
The modularity is a statistic that quantifies the degree to which the
network may be subdivided into such clearly delineated groups.</p>
<p>The Louvain algorithm is a fast and accurate community detection
algorithm (as of writing). The algorithm may also be used to detect
hierarchical community structure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>directed weighted/binary connection matrix</p>
</div></blockquote>
<p><strong>gamma</strong> : float</p>
<blockquote>
<div><p>resolution parameter. default value=1. Values 0 &lt;= gamma &lt; 1 detect
larger modules while gamma &gt; 1 detects smaller modules.</p>
</div></blockquote>
<p><strong>hierarchy</strong> : bool</p>
<blockquote>
<div><p>Enables hierarchical output. Defalut value=False</p>
</div></blockquote>
<p><strong>seed</strong> : int | None</p>
<blockquote>
<div><p>random seed. default value=None. if None, seeds from /dev/urandom.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ci</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>refined community affiliation vector. If hierarchical output enabled,
it is an NxH np.ndarray instead with multiple iterations</p>
</div></blockquote>
<p><strong>Q</strong> : float</p>
<blockquote class="last">
<div><p>optimized modularity metric. If hierarchical output enabled, becomes
an Hx1 array of floats instead.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Ci and Q may vary from run to run, due to heuristics in the
algorithm. Consequently, it may be worth to compare multiple runs.</p>
</dd></dl>

<dl class="function">
<dt id="bct.modularity_louvain_und">
<tt class="descclassname">bct.</tt><tt class="descname">modularity_louvain_und</tt><big>(</big><em>W</em>, <em>gamma=1</em>, <em>hierarchy=False</em>, <em>seed=None</em><big>)</big><a class="headerlink" href="#bct.modularity_louvain_und" title="Permalink to this definition">¶</a></dt>
<dd><p>The optimal community structure is a subdivision of the network into
nonoverlapping groups of nodes in a way that maximizes the number of
within-group edges, and minimizes the number of between-group edges.
The modularity is a statistic that quantifies the degree to which the
network may be subdivided into such clearly delineated groups.</p>
<p>The Louvain algorithm is a fast and accurate community detection
algorithm (as of writing). The algorithm may also be used to detect
hierarchical community structure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>undirected weighted/binary connection matrix</p>
</div></blockquote>
<p><strong>gamma</strong> : float</p>
<blockquote>
<div><p>resolution parameter. default value=1. Values 0 &lt;= gamma &lt; 1 detect
larger modules while gamma &gt; 1 detects smaller modules.</p>
</div></blockquote>
<p><strong>hierarchy</strong> : bool</p>
<blockquote>
<div><p>Enables hierarchical output. Defalut value=False</p>
</div></blockquote>
<p><strong>seed</strong> : int | None</p>
<blockquote>
<div><p>random seed. default value=None. if None, seeds from /dev/urandom.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ci</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>refined community affiliation vector. If hierarchical output enabled,
it is an NxH np.ndarray instead with multiple iterations</p>
</div></blockquote>
<p><strong>Q</strong> : float</p>
<blockquote class="last">
<div><p>optimized modularity metric. If hierarchical output enabled, becomes
an Hx1 array of floats instead.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Ci and Q may vary from run to run, due to heuristics in the
algorithm. Consequently, it may be worth to compare multiple runs.</p>
</dd></dl>

<dl class="function">
<dt id="bct.modularity_louvain_und_sign">
<tt class="descclassname">bct.</tt><tt class="descname">modularity_louvain_und_sign</tt><big>(</big><em>W</em>, <em>gamma=1</em>, <em>qtype='sta'</em>, <em>seed=None</em><big>)</big><a class="headerlink" href="#bct.modularity_louvain_und_sign" title="Permalink to this definition">¶</a></dt>
<dd><p>The optimal community structure is a subdivision of the network into
nonoverlapping groups of nodes in a way that maximizes the number of
within-group edges, and minimizes the number of between-group edges.
The modularity is a statistic that quantifies the degree to which the
network may be subdivided into such clearly delineated groups.</p>
<p>The Louvain algorithm is a fast and accurate community detection
algorithm (at the time of writing).</p>
<p>Use this function as opposed to modularity_louvain_und() only if the
network contains a mix of positive and negative weights.  If the network
contains all positive weights, the output will be equivalent to that of
modularity_louvain_und().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>undirected weighted/binary connection matrix with positive and
negative weights</p>
</div></blockquote>
<p><strong>qtype</strong> : str</p>
<blockquote>
<div><p>modularity type. Can be &#8216;sta&#8217; (default), &#8216;pos&#8217;, &#8216;smp&#8217;, &#8216;gja&#8217;, &#8216;neg&#8217;.
See Rubinov and Sporns (2011) for a description.</p>
</div></blockquote>
<p><strong>gamma</strong> : float</p>
<blockquote>
<div><p>resolution parameter. default value=1. Values 0 &lt;= gamma &lt; 1 detect
larger modules while gamma &gt; 1 detects smaller modules.</p>
</div></blockquote>
<p><strong>seed</strong> : int | None</p>
<blockquote>
<div><p>random seed. default value=None. if None, seeds from /dev/urandom.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ci</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>refined community affiliation vector</p>
</div></blockquote>
<p><strong>Q</strong> : float</p>
<blockquote class="last">
<div><p>optimized modularity metric</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Ci and Q may vary from run to run, due to heuristics in the
algorithm. Consequently, it may be worth to compare multiple runs.</p>
</dd></dl>

<dl class="function">
<dt id="bct.modularity_probtune_und_sign">
<tt class="descclassname">bct.</tt><tt class="descname">modularity_probtune_und_sign</tt><big>(</big><em>W</em>, <em>qtype='sta'</em>, <em>gamma=1</em>, <em>ci=None</em>, <em>p=0.45</em>, <em>seed=None</em><big>)</big><a class="headerlink" href="#bct.modularity_probtune_und_sign" title="Permalink to this definition">¶</a></dt>
<dd><p>The optimal community structure is a subdivision of the network into
nonoverlapping groups of nodes in a way that maximizes the number of
within-group edges, and minimizes the number of between-group edges.
The modularity is a statistic that quantifies the degree to which the
network may be subdivided into such clearly delineated groups.
High-modularity degeneracy is the presence of many topologically
distinct high-modularity partitions of the network.</p>
<p>This algorithm is inspired by the Kernighan-Lin fine-tuning algorithm
and is designed to probabilistically refine a previously detected
community by incorporating random node moves into a finetuning
algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>undirected weighted/binary connection matrix with positive and
negative weights</p>
</div></blockquote>
<p><strong>qtype</strong> : str</p>
<blockquote>
<div><p>modularity type. Can be &#8216;sta&#8217; (default), &#8216;pos&#8217;, &#8216;smp&#8217;, &#8216;gja&#8217;, &#8216;neg&#8217;.
See Rubinov and Sporns (2011) for a description.</p>
</div></blockquote>
<p><strong>gamma</strong> : float</p>
<blockquote>
<div><p>resolution parameter. default value=1. Values 0 &lt;= gamma &lt; 1 detect
larger modules while gamma &gt; 1 detects smaller modules.</p>
</div></blockquote>
<p><strong>ci</strong> : Nx1 np.ndarray | None</p>
<blockquote>
<div><p>initial community affiliation vector</p>
</div></blockquote>
<p><strong>p</strong> : float</p>
<blockquote>
<div><p>probability of random node moves. Default value = 0.45</p>
</div></blockquote>
<p><strong>seed</strong> : int | None</p>
<blockquote>
<div><p>random seed. default value=None. if None, seeds from /dev/urandom.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ci</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>refined community affiliation vector</p>
</div></blockquote>
<p><strong>Q</strong> : float</p>
<blockquote class="last">
<div><p>optimized modularity metric</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Ci and Q may vary from run to run, due to heuristics in the
algorithm. Consequently, it may be worth to compare multiple runs.</p>
</dd></dl>

<dl class="function">
<dt id="bct.partition_distance">
<tt class="descclassname">bct.</tt><tt class="descname">partition_distance</tt><big>(</big><em>cx</em>, <em>cy</em><big>)</big><a class="headerlink" href="#bct.partition_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>This function quantifies the distance between pairs of community
partitions with information theoretic measures.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>cx</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>community affiliation vector X</p>
</div></blockquote>
<p><strong>cy</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>community affiliation vector Y</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>VIn</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>normalized variation of information</p>
</div></blockquote>
<p><strong>MIn</strong> : Nx1 np.ndarray</p>
<blockquote class="last">
<div><p>normalized mutual information</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<dl class="docutils">
<dt>(Definitions:</dt>
<dd>VIn = [H(X) + H(Y) - 2MI(X,Y)]/log(n)
MIn = 2MI(X,Y)/[H(X)+H(Y)]</dd>
</dl>
<p>where H is entropy, MI is mutual information and n is number of nodes)</p>
</dd></dl>

</div>
<div class="section" id="motif">
<h2>Motif<a class="headerlink" href="#motif" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="bct.find_motif34">
<tt class="descclassname">bct.</tt><tt class="descname">find_motif34</tt><big>(</big><em>m</em>, <em>n=None</em><big>)</big><a class="headerlink" href="#bct.find_motif34" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns all motif isomorphs for a given motif id and
class (3 or 4). The function also returns the motif id for a given
motif matrix</p>
<ol class="arabic">
<li><dl class="first docutils">
<dt>Input:       Motif_id,           e.g. 1 to 13, if class is 3</dt>
<dd><p class="first last">Motif_class,        number of nodes, 3 or 4.</p>
</dd>
</dl>
</li>
</ol>
<p>Output:      Motif_matrices,     all isomorphs for the given motif</p>
<p>2. Input:       Motif_matrix        e.g. [0 1 0; 0 0 1; 1 0 0]
Output       Motif_id            e.g. 1 to 13, if class is 3</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>m</strong> : int | matrix</p>
<blockquote>
<div><p>In use case 1, a motif_id which is an integer.
In use case 2, the entire matrix of the motif
(e.g. [0 1 0; 0 0 1; 1 0 0])</p>
</div></blockquote>
<p><strong>n</strong> : int | None</p>
<blockquote>
<div><p>In use case 1, the motif class, which is the number of nodes. This is
either 3 or 4.
In use case 2, None.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>M</strong> : np.ndarray | int</p>
<blockquote class="last">
<div><p>In use case 1, returns all isomorphs for the given motif
In use case 2, returns the motif_id for the specified motif matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.motif3funct_bin">
<tt class="descclassname">bct.</tt><tt class="descname">motif3funct_bin</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#bct.motif3funct_bin" title="Permalink to this definition">¶</a></dt>
<dd><p>Functional motifs are subsets of connection patterns embedded within
anatomical motifs. Motif frequency is the frequency of occurrence of
motifs around a node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary directed connection matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>F</strong> : 13xN np.ndarray</p>
<blockquote>
<div><p>motif frequency matrix</p>
</div></blockquote>
<p><strong>f</strong> : 13x1 np.ndarray</p>
<blockquote class="last">
<div><p>motif frequency vector (averaged over all nodes)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.motif3funct_wei">
<tt class="descclassname">bct.</tt><tt class="descname">motif3funct_wei</tt><big>(</big><em>W</em><big>)</big><a class="headerlink" href="#bct.motif3funct_wei" title="Permalink to this definition">¶</a></dt>
<dd><p>Functional motifs are subsets of connection patterns embedded within
anatomical motifs. Motif frequency is the frequency of occurrence of
motifs around a node. Motif intensity and coherence are weighted
generalizations of motif frequency.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>weighted directed connection matrix (all weights between 0 and 1)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>I</strong> : 13xN np.ndarray</p>
<blockquote>
<div><p>motif intensity matrix</p>
</div></blockquote>
<p><strong>Q</strong> : 13xN np.ndarray</p>
<blockquote>
<div><p>motif coherence matrix</p>
</div></blockquote>
<p><strong>F</strong> : 13xN np.ndarray</p>
<blockquote class="last">
<div><p>motif frequency matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Average intensity and coherence are given by I./F and Q./F.</p>
</dd></dl>

<dl class="function">
<dt id="bct.motif3struct_bin">
<tt class="descclassname">bct.</tt><tt class="descname">motif3struct_bin</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#bct.motif3struct_bin" title="Permalink to this definition">¶</a></dt>
<dd><p>Structural motifs are patterns of local connectivity. Motif frequency
is the frequency of occurrence of motifs around a node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary directed connection matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>F</strong> : 13xN np.ndarray</p>
<blockquote>
<div><p>motif frequency matrix</p>
</div></blockquote>
<p><strong>f</strong> : 13x1 np.ndarray</p>
<blockquote class="last">
<div><p>motif frequency vector (averaged over all nodes)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.motif3struct_wei">
<tt class="descclassname">bct.</tt><tt class="descname">motif3struct_wei</tt><big>(</big><em>W</em><big>)</big><a class="headerlink" href="#bct.motif3struct_wei" title="Permalink to this definition">¶</a></dt>
<dd><p>Structural motifs are patterns of local connectivity. Motif frequency
is the frequency of occurrence of motifs around a node. Motif intensity
and coherence are weighted generalizations of motif frequency.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>weighted directed connection matrix (all weights between 0 and 1)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>I</strong> : 13xN np.ndarray</p>
<blockquote>
<div><p>motif intensity matrix</p>
</div></blockquote>
<p><strong>Q</strong> : 13xN np.ndarray</p>
<blockquote>
<div><p>motif coherence matrix</p>
</div></blockquote>
<p><strong>F</strong> : 13xN np.ndarray</p>
<blockquote class="last">
<div><p>motif frequency matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Average intensity and coherence are given by I./F and Q./F.</p>
</dd></dl>

<dl class="function">
<dt id="bct.motif4funct_bin">
<tt class="descclassname">bct.</tt><tt class="descname">motif4funct_bin</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#bct.motif4funct_bin" title="Permalink to this definition">¶</a></dt>
<dd><p>Functional motifs are subsets of connection patterns embedded within
anatomical motifs. Motif frequency is the frequency of occurrence of
motifs around a node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary directed connection matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>F</strong> : 199xN np.ndarray</p>
<blockquote>
<div><p>motif frequency matrix</p>
</div></blockquote>
<p><strong>f</strong> : 199x1 np.ndarray</p>
<blockquote class="last">
<div><p>motif frequency vector (averaged over all nodes)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.motif4funct_wei">
<tt class="descclassname">bct.</tt><tt class="descname">motif4funct_wei</tt><big>(</big><em>W</em><big>)</big><a class="headerlink" href="#bct.motif4funct_wei" title="Permalink to this definition">¶</a></dt>
<dd><p>Functional motifs are subsets of connection patterns embedded within
anatomical motifs. Motif frequency is the frequency of occurrence of
motifs around a node. Motif intensity and coherence are weighted
generalizations of motif frequency.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>weighted directed connection matrix (all weights between 0 and 1)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>I</strong> : 199xN np.ndarray</p>
<blockquote>
<div><p>motif intensity matrix</p>
</div></blockquote>
<p><strong>Q</strong> : 199xN np.ndarray</p>
<blockquote>
<div><p>motif coherence matrix</p>
</div></blockquote>
<p><strong>F</strong> : 199xN np.ndarray</p>
<blockquote class="last">
<div><p>motif frequency matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Average intensity and coherence are given by I./F and Q./F.</p>
</dd></dl>

<dl class="function">
<dt id="bct.motif4struct_bin">
<tt class="descclassname">bct.</tt><tt class="descname">motif4struct_bin</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#bct.motif4struct_bin" title="Permalink to this definition">¶</a></dt>
<dd><p>Structural motifs are patterns of local connectivity. Motif frequency
is the frequency of occurrence of motifs around a node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary directed connection matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>F</strong> : 199xN np.ndarray</p>
<blockquote>
<div><p>motif frequency matrix</p>
</div></blockquote>
<p><strong>f</strong> : 199x1 np.ndarray</p>
<blockquote class="last">
<div><p>motif frequency vector (averaged over all nodes)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.motif4struct_wei">
<tt class="descclassname">bct.</tt><tt class="descname">motif4struct_wei</tt><big>(</big><em>W</em><big>)</big><a class="headerlink" href="#bct.motif4struct_wei" title="Permalink to this definition">¶</a></dt>
<dd><p>Structural motifs are patterns of local connectivity. Motif frequency
is the frequency of occurrence of motifs around a node. Motif intensity
and coherence are weighted generalizations of motif frequency.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>weighted directed connection matrix (all weights between 0 and 1)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>I</strong> : 199xN np.ndarray</p>
<blockquote>
<div><p>motif intensity matrix</p>
</div></blockquote>
<p><strong>Q</strong> : 199xN np.ndarray</p>
<blockquote>
<div><p>motif coherence matrix</p>
</div></blockquote>
<p><strong>F</strong> : 199xN np.ndarray</p>
<blockquote class="last">
<div><p>motif frequency matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Average intensity and coherence are given by I./F and Q./F.</p>
</dd></dl>

</div>
<div class="section" id="miscellaneous">
<h2>Miscellaneous<a class="headerlink" href="#miscellaneous" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="bct.threshold_absolute">
<tt class="descclassname">bct.</tt><tt class="descname">threshold_absolute</tt><big>(</big><em>W</em>, <em>thr</em>, <em>copy=True</em><big>)</big><a class="headerlink" href="#bct.threshold_absolute" title="Permalink to this definition">¶</a></dt>
<dd><p>This function thresholds the connectivity matrix by absolute weight
magnitude. All weights below the given threshold, and all weights
on the main diagonal (self-self connections) are set to 0.</p>
<p>If copy is not set, this function will <em>modify W in place.</em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : np.ndarray</p>
<blockquote>
<div><p>weighted connectivity matrix</p>
</div></blockquote>
<p><strong>thr</strong> : float</p>
<blockquote>
<div><p>absolute weight threshold</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>if True, returns a copy of the matrix. Otherwise, modifies the matrix
in place. Default value=True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>W</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>thresholded connectivity matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.threshold_proportional">
<tt class="descclassname">bct.</tt><tt class="descname">threshold_proportional</tt><big>(</big><em>W</em>, <em>p</em>, <em>copy=True</em><big>)</big><a class="headerlink" href="#bct.threshold_proportional" title="Permalink to this definition">¶</a></dt>
<dd><p>This function &#8220;thresholds&#8221; the connectivity matrix by preserving a
proportion p (0&lt;p&lt;1) of the strongest weights. All other weights, and
all weights on the main diagonal (self-self connections) are set to 0.</p>
<p>If copy is not set, this function will <em>modify W in place.</em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : np.ndarray</p>
<blockquote>
<div><p>weighted connectivity matrix</p>
</div></blockquote>
<p><strong>p</strong> : float</p>
<blockquote>
<div><p>proportional weight threshold (0&lt;p&lt;1)</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>if True, returns a copy of the matrix. Otherwise, modifies the matrix
in place. Default value=True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>W</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>thresholded connectivity matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The proportion of elements set to 0 is a fraction of all elements
in the matrix, whether or not they are already 0. That is, this function
has the following behavior:</p>
<p>&gt;&gt; x = np.random.random((10,10))
&gt;&gt; x_25 = threshold_proportional(x, .25)
&gt;&gt; np.size(np.where(x_25)) #note this double counts each nonzero element
46
&gt;&gt; x_125 = threshold_proportional(x, .125)
&gt;&gt; np.size(np.where(x_125))
22
&gt;&gt; x_test = threshold_proportional(x_25, .5)
&gt;&gt; np.size(np.where(x_test))
46</p>
<p>That is, the 50% thresholding of x_25 does nothing because &gt;=50% of the
elements in x_25 are aleady &lt;=0. This behavior is the same as in BCT. Be
careful with matrices that are both signed and sparse.</p>
</dd></dl>

<dl class="function">
<dt id="bct.weight_conversion">
<tt class="descclassname">bct.</tt><tt class="descname">weight_conversion</tt><big>(</big><em>W</em>, <em>wcm</em>, <em>copy=True</em><big>)</big><a class="headerlink" href="#bct.weight_conversion" title="Permalink to this definition">¶</a></dt>
<dd><p>W_bin = weight_conversion(W, &#8216;binarize&#8217;);
W_nrm = weight_conversion(W, &#8216;normalize&#8217;);
L = weight_conversion(W, &#8216;lengths&#8217;);</p>
<p>This function may either binarize an input weighted connection matrix,
normalize an input weighted connection matrix or convert an input
weighted connection matrix to a weighted connection-length matrix.</p>
<p>Binarization converts all present connection weights to 1.</p>
<p>Normalization scales all weight magnitudes to the range [0,1] and
should be done prior to computing some weighted measures, such as the
weighted clustering coefficient.</p>
<p>Conversion of connection weights to connection lengths is needed
prior to computation of weighted distance-based measures, such as
distance and betweenness centrality. In a weighted connection network,
higher weights are naturally interpreted as shorter lengths. The
connection-lengths matrix here is defined as the inverse of the
connection-weights matrix.</p>
<p>If copy is not set, this function will <em>modify W in place.</em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>weighted connectivity matrix</p>
</div></blockquote>
<p><strong>wcm</strong> : str</p>
<blockquote>
<div><p>weight conversion command.
&#8216;binarize&#8217; : binarize weights
&#8216;normalize&#8217; : normalize weights
&#8216;lengths&#8217; : convert weights to lengths (invert matrix)</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>if True, returns a copy of the matrix. Otherwise, modifies the matrix
in place. Default value=True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote class="last">
<div><p>connectivity matrix with specified changes</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function is included for compatibility with BCT. But there are
other functions binarize(), normalize() and invert() which are simpler to
call directly.</p>
</dd></dl>

<dl class="function">
<dt id="bct.binarize">
<tt class="descclassname">bct.</tt><tt class="descname">binarize</tt><big>(</big><em>W</em>, <em>copy=True</em><big>)</big><a class="headerlink" href="#bct.binarize" title="Permalink to this definition">¶</a></dt>
<dd><p>Binarizes an input weighted connection matrix.  If copy is not set, this
function will <em>modify W in place.</em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>weighted connectivity matrix</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>if True, returns a copy of the matrix. Otherwise, modifies the matrix
in place. Default value=True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote class="last">
<div><p>binary connectivity matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.normalize">
<tt class="descclassname">bct.</tt><tt class="descname">normalize</tt><big>(</big><em>W</em>, <em>copy=True</em><big>)</big><a class="headerlink" href="#bct.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalizes an input weighted connection matrix.  If copy is not set, this
function will <em>modify W in place.</em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : np.ndarray</p>
<blockquote>
<div><p>weighted connectivity matrix</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>if True, returns a copy of the matrix. Otherwise, modifies the matrix
in place. Default value=True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>W</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>normalized connectivity matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.invert">
<tt class="descclassname">bct.</tt><tt class="descname">invert</tt><big>(</big><em>W</em>, <em>copy=True</em><big>)</big><a class="headerlink" href="#bct.invert" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverts elementwise the weights in an input connection matrix.
In other words, change the from the matrix of internode strengths to the
matrix of internode distances.</p>
<p>If copy is not set, this function will <em>modify W in place.</em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : np.ndarray</p>
<blockquote>
<div><p>weighted connectivity matrix</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>if True, returns a copy of the matrix. Otherwise, modifies the matrix
in place. Default value=True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>W</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>inverted connectivity matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.autofix">
<tt class="descclassname">bct.</tt><tt class="descname">autofix</tt><big>(</big><em>W</em>, <em>copy=True</em><big>)</big><a class="headerlink" href="#bct.autofix" title="Permalink to this definition">¶</a></dt>
<dd><p>Fix a bunch of common problems. More specifically, remove Inf and NaN,
ensure exact binariness and symmetry (i.e. remove floating point
instability), and zero diagonal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : np.ndarray</p>
<blockquote>
<div><p>weighted connectivity matrix</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>if True, returns a copy of the matrix. Otherwise, modifies the matrix
in place. Default value=True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>W</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>connectivity matrix with fixes applied</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="physical-connectivity">
<h2>Physical Connectivity<a class="headerlink" href="#physical-connectivity" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="bct.density_dir">
<tt class="descclassname">bct.</tt><tt class="descname">density_dir</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.density_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Density is the fraction of present connections to possible connections.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>directed weighted/binary connection matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>kden</strong> : float</p>
<blockquote>
<div><p>density</p>
</div></blockquote>
<p><strong>N</strong> : int</p>
<blockquote>
<div><p>number of vertices</p>
</div></blockquote>
<p><strong>k</strong> : int</p>
<blockquote class="last">
<div><p>number of edges</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Assumes CIJ is directed and has no self-connections.
Weight information is discarded.</p>
</dd></dl>

<dl class="function">
<dt id="bct.density_und">
<tt class="descclassname">bct.</tt><tt class="descname">density_und</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.density_und" title="Permalink to this definition">¶</a></dt>
<dd><p>Density is the fraction of present connections to possible connections.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>undirected (weighted/binary) connection matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>kden</strong> : float</p>
<blockquote>
<div><p>density</p>
</div></blockquote>
<p><strong>N</strong> : int</p>
<blockquote>
<div><p>number of vertices</p>
</div></blockquote>
<p><strong>k</strong> : int</p>
<blockquote class="last">
<div><p>number of edges</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<dl class="docutils">
<dt>Assumes CIJ is undirected and has no self-connections.</dt>
<dd>Weight information is discarded.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.rentian_scaling">
<tt class="descclassname">bct.</tt><tt class="descname">rentian_scaling</tt><big>(</big><em>A</em>, <em>xyz</em>, <em>n</em><big>)</big><a class="headerlink" href="#bct.rentian_scaling" title="Permalink to this definition">¶</a></dt>
<dd><p>Physical Rentian scaling (or more simply Rentian scaling) is a property
of systems that are cost-efficiently embedded into physical space. It is
what is called a &#8220;topo-physical&#8221; property because it combines information
regarding the topological organization of the graph with information
about the physical placement of connections. Rentian scaling is present
in very large scale integrated circuits, the C. elegans neuronal network,
and morphometric and diffusion-based graphs of human anatomical networks.
Rentian scaling is determined by partitioning the system into cubes,
counting the number of nodes inside of each cube (N), and the number of
edges traversing the boundary of each cube (E). If the system displays
Rentian scaling, these two variables N and E will scale with one another
in loglog space. The Rent&#8217;s exponent is given by the slope of log10(E)
vs. log10(N), and can be reported alone or can be compared to the
theoretical minimum Rent&#8217;s exponent to determine how cost efficiently the
network has been embedded into physical space. Note: if a system displays
Rentian scaling, it does not automatically mean that the system is
cost-efficiently embedded (although it does suggest that). Validation
occurs when comparing to the theoretical minimum Rent&#8217;s exponent for that
system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>unweighted, binary, symmetric adjacency matrix</p>
</div></blockquote>
<p><strong>xyz</strong> : Nx3 np.ndarray</p>
<blockquote>
<div><p>vector of node placement coordinates</p>
</div></blockquote>
<p><strong>n</strong> : int</p>
<blockquote>
<div><p>Number of partitions to compute. Each partition is a data point; you
want a large enough number to adequately compute Rent&#8217;s exponent.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>N</strong> : Mx1 np.ndarray</p>
<blockquote>
<div><p>Number of nodes in each of the M partitions</p>
</div></blockquote>
<p class="last"><strong>E</strong> : Mx1 np.ndarray</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Subsequent Analysis:
Rentian scaling plots are then created by: figure; loglog(E,N,&#8217;*&#8217;);
To determine the Rent&#8217;s exponent, p, it is important not to use
partitions which may
be affected by boundary conditions. In Bassett et al. 2010 PLoS CB, only
partitions with N&lt;M/2 were used in the estimation of the Rent&#8217;s exponent.
Thus, we can define N_prime = N(find(N&lt;M/2)) and
E_prime = E(find(N&lt;M/2)).
Next we need to determine the slope of Eprime vs. Nprime in loglog space,
which is the Rent&#8217;s
exponent. There are many ways of doing this with more or less statistical
rigor. Robustfit in MATLAB is one such option:</p>
<blockquote>
<div>[b,stats] = robustfit(log10(N_prime),log10(E_prime))</div></blockquote>
<p>Then the Rent&#8217;s exponent is b(1,2) and the standard error of the
estimation is given by stats.se(1,2).</p>
<p>Note: n=5000 was used in Bassett et al. 2010 in PLoS CB.</p>
</dd></dl>

</div>
<div class="section" id="reference">
<h2>Reference<a class="headerlink" href="#reference" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="bct.latmio_dir_connected">
<tt class="descclassname">bct.</tt><tt class="descname">latmio_dir_connected</tt><big>(</big><em>R</em>, <em>itr</em>, <em>D=None</em><big>)</big><a class="headerlink" href="#bct.latmio_dir_connected" title="Permalink to this definition">¶</a></dt>
<dd><p>This function &#8220;latticizes&#8221; a directed network, while preserving the in-
and out-degree distributions. In weighted networks, the function
preserves the out-strength but not the in-strength distributions. The
function also ensures that the randomized network maintains
connectedness, the ability for every node to reach every other node in
the network. The input network for this function must be connected.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>R</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>directed binary/weighted connection matrix</p>
</div></blockquote>
<p><strong>itr</strong> : int</p>
<blockquote>
<div><p>rewiring parameter. Each edge is rewired approximately itr times.</p>
</div></blockquote>
<p><strong>D</strong> : np.ndarray | None</p>
<blockquote>
<div><p>distance-to-diagonal matrix. Defaults to the actual distance matrix
if not specified.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Rlatt</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>latticized network in original node ordering</p>
</div></blockquote>
<p><strong>Rrp</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>latticized network in node ordering used for latticization</p>
</div></blockquote>
<p><strong>ind_rp</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>node ordering used for latticization</p>
</div></blockquote>
<p><strong>eff</strong> : int</p>
<blockquote class="last">
<div><p>number of actual rewirings carried out</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.latmio_dir">
<tt class="descclassname">bct.</tt><tt class="descname">latmio_dir</tt><big>(</big><em>R</em>, <em>itr</em>, <em>D=None</em><big>)</big><a class="headerlink" href="#bct.latmio_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>This function &#8220;latticizes&#8221; a directed network, while preserving the in-
and out-degree distributions. In weighted networks, the function
preserves the out-strength but not the in-strength distributions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>R</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>directed binary/weighted connection matrix</p>
</div></blockquote>
<p><strong>itr</strong> : int</p>
<blockquote>
<div><p>rewiring parameter. Each edge is rewired approximately itr times.</p>
</div></blockquote>
<p><strong>D</strong> : np.ndarray | None</p>
<blockquote>
<div><p>distance-to-diagonal matrix. Defaults to the actual distance matrix
if not specified.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Rlatt</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>latticized network in original node ordering</p>
</div></blockquote>
<p><strong>Rrp</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>latticized network in node ordering used for latticization</p>
</div></blockquote>
<p><strong>ind_rp</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>node ordering used for latticization</p>
</div></blockquote>
<p><strong>eff</strong> : int</p>
<blockquote class="last">
<div><p>number of actual rewirings carried out</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.latmio_und_connected">
<tt class="descclassname">bct.</tt><tt class="descname">latmio_und_connected</tt><big>(</big><em>R</em>, <em>itr</em>, <em>D=None</em><big>)</big><a class="headerlink" href="#bct.latmio_und_connected" title="Permalink to this definition">¶</a></dt>
<dd><p>This function &#8220;latticizes&#8221; an undirected network, while preserving the
degree distribution. The function does not preserve the strength
distribution in weighted networks. The function also ensures that the
randomized network maintains connectedness, the ability for every node
to reach every other node in the network. The input network for this
function must be connected.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>R</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>undirected binary/weighted connection matrix</p>
</div></blockquote>
<p><strong>itr</strong> : int</p>
<blockquote>
<div><p>rewiring parameter. Each edge is rewired approximately itr times.</p>
</div></blockquote>
<p><strong>D</strong> : np.ndarray | None</p>
<blockquote>
<div><p>distance-to-diagonal matrix. Defaults to the actual distance matrix
if not specified.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Rlatt</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>latticized network in original node ordering</p>
</div></blockquote>
<p><strong>Rrp</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>latticized network in node ordering used for latticization</p>
</div></blockquote>
<p><strong>ind_rp</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>node ordering used for latticization</p>
</div></blockquote>
<p><strong>eff</strong> : int</p>
<blockquote class="last">
<div><p>number of actual rewirings carried out</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.latmio_und">
<tt class="descclassname">bct.</tt><tt class="descname">latmio_und</tt><big>(</big><em>R</em>, <em>itr</em>, <em>D=None</em><big>)</big><a class="headerlink" href="#bct.latmio_und" title="Permalink to this definition">¶</a></dt>
<dd><p>This function &#8220;latticizes&#8221; an undirected network, while preserving the
degree distribution. The function does not preserve the strength
distribution in weighted networks.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>R</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>undirected binary/weighted connection matrix</p>
</div></blockquote>
<p><strong>itr</strong> : int</p>
<blockquote>
<div><p>rewiring parameter. Each edge is rewired approximately itr times.</p>
</div></blockquote>
<p><strong>D</strong> : np.ndarray | None</p>
<blockquote>
<div><p>distance-to-diagonal matrix. Defaults to the actual distance matrix
if not specified.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Rlatt</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>latticized network in original node ordering</p>
</div></blockquote>
<p><strong>Rrp</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>latticized network in node ordering used for latticization</p>
</div></blockquote>
<p><strong>ind_rp</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>node ordering used for latticization</p>
</div></blockquote>
<p><strong>eff</strong> : int</p>
<blockquote class="last">
<div><p>number of actual rewirings carried out</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.makeevenCIJ">
<tt class="descclassname">bct.</tt><tt class="descname">makeevenCIJ</tt><big>(</big><em>n</em>, <em>k</em>, <em>sz_cl</em><big>)</big><a class="headerlink" href="#bct.makeevenCIJ" title="Permalink to this definition">¶</a></dt>
<dd><p>This function generates a random, directed network with a specified
number of fully connected modules linked together by evenly distributed
remaining random connections.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>number of vertices (must be power of 2)</p>
</div></blockquote>
<p><strong>K</strong> : int</p>
<blockquote>
<div><p>number of edges</p>
</div></blockquote>
<p><strong>sz_cl</strong> : int</p>
<blockquote>
<div><p>size of clusters (must be power of 2)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote class="last">
<div><p>connection matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<dl class="docutils">
<dt>N must be a power of 2.</dt>
<dd>A warning is generated if all modules contain more edges than K.
Cluster size is 2^sz_cl;</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.makefractalCIJ">
<tt class="descclassname">bct.</tt><tt class="descname">makefractalCIJ</tt><big>(</big><em>mx_lvl</em>, <em>E</em>, <em>sz_cl</em><big>)</big><a class="headerlink" href="#bct.makefractalCIJ" title="Permalink to this definition">¶</a></dt>
<dd><p>This function generates a directed network with a hierarchical modular
organization. All modules are fully connected and connection density
decays as 1/(E^n), with n = index of hierarchical level.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mx_lvl</strong> : int</p>
<blockquote>
<div><p>number of hierarchical levels, N = 2^mx_lvl</p>
</div></blockquote>
<p><strong>E</strong> : int</p>
<blockquote>
<div><p>connection density fall off per level</p>
</div></blockquote>
<p><strong>sz_cl</strong> : int</p>
<blockquote>
<div><p>size of clusters (must be power of 2)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>connection matrix</p>
</div></blockquote>
<p><strong>K</strong> : int</p>
<blockquote class="last">
<div><p>number of connections present in output CIJ</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.makerandCIJdegreesfixed">
<tt class="descclassname">bct.</tt><tt class="descname">makerandCIJdegreesfixed</tt><big>(</big><em>inv</em>, <em>outv</em><big>)</big><a class="headerlink" href="#bct.makerandCIJdegreesfixed" title="Permalink to this definition">¶</a></dt>
<dd><p>This function generates a directed random network with a specified
in-degree and out-degree sequence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>inv</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>in-degree vector</p>
</div></blockquote>
<p><strong>outv</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>out-degree vector</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>CIJ</strong> : NxN np.ndarray</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<dl class="docutils">
<dt>Necessary conditions include:</dt>
<dd><blockquote class="first">
<div>length(in) = length(out) = n
sum(in) = sum(out) = k
in(i), out(i) &lt; n-1
in(i) + out(j) &lt; n+2
in(i) + out(i) &lt; n</div></blockquote>
<p>No connections are placed on the main diagonal</p>
<p class="last">The algorithm used in this function is not, technically, guaranteed to
terminate. If a valid distribution of in and out degrees is provided,
this function will find it in bounded time with probability
1-(1/(2*(k^2))). This turns out to be a serious problem when
computing infinite degree matrices, but offers good performance
otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.makerandCIJ_dir">
<tt class="descclassname">bct.</tt><tt class="descname">makerandCIJ_dir</tt><big>(</big><em>n</em>, <em>k</em><big>)</big><a class="headerlink" href="#bct.makerandCIJ_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>This function generates a directed random network</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>number of vertices</p>
</div></blockquote>
<p><strong>K</strong> : int</p>
<blockquote>
<div><p>number of edges</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote class="last">
<div><p>directed random connection matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>no connections are placed on the main diagonal.</p>
</dd></dl>

<dl class="function">
<dt id="bct.makerandCIJ_und">
<tt class="descclassname">bct.</tt><tt class="descname">makerandCIJ_und</tt><big>(</big><em>n</em>, <em>k</em><big>)</big><a class="headerlink" href="#bct.makerandCIJ_und" title="Permalink to this definition">¶</a></dt>
<dd><p>This function generates an undirected random network</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>number of vertices</p>
</div></blockquote>
<p><strong>K</strong> : int</p>
<blockquote>
<div><p>number of edges</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote class="last">
<div><p>undirected random connection matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>no connections are placed on the main diagonal.</p>
</dd></dl>

<dl class="function">
<dt id="bct.makeringlatticeCIJ">
<tt class="descclassname">bct.</tt><tt class="descname">makeringlatticeCIJ</tt><big>(</big><em>n</em>, <em>k</em><big>)</big><a class="headerlink" href="#bct.makeringlatticeCIJ" title="Permalink to this definition">¶</a></dt>
<dd><p>This function generates a directed lattice network with toroidal
boundary counditions (i.e. with ring-like &#8220;wrapping around&#8221;).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>number of vertices</p>
</div></blockquote>
<p><strong>K</strong> : int</p>
<blockquote>
<div><p>number of edges</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote class="last">
<div><p>connection matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The lattice is made by placing connections as close as possible
to the main diagonal, with wrapping around. No connections are made
on the main diagonal. In/Outdegree is kept approx. constant at K/N.</p>
</dd></dl>

<dl class="function">
<dt id="bct.maketoeplitzCIJ">
<tt class="descclassname">bct.</tt><tt class="descname">maketoeplitzCIJ</tt><big>(</big><em>n</em>, <em>k</em>, <em>s</em><big>)</big><a class="headerlink" href="#bct.maketoeplitzCIJ" title="Permalink to this definition">¶</a></dt>
<dd><p>This function generates a directed network with a Gaussian drop-off in
edge density with increasing distance from the main diagonal. There are
toroidal boundary counditions (i.e. no ring-like &#8220;wrapping around&#8221;).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>number of vertices</p>
</div></blockquote>
<p><strong>K</strong> : int</p>
<blockquote>
<div><p>number of edges</p>
</div></blockquote>
<p><strong>s</strong> : float</p>
<blockquote>
<div><p>standard deviation of toeplitz</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote class="last">
<div><p>connection matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>no connections are placed on the main diagonal.</p>
</dd></dl>

<dl class="function">
<dt id="bct.null_model_dir_sign">
<tt class="descclassname">bct.</tt><tt class="descname">null_model_dir_sign</tt><big>(</big><em>W</em>, <em>bin_swaps=5</em>, <em>wei_freq=0.1</em><big>)</big><a class="headerlink" href="#bct.null_model_dir_sign" title="Permalink to this definition">¶</a></dt>
<dd><p>This function randomizes an directed network with positive and
negative weights, while preserving the degree and strength
distributions. This function calls randmio_dir.m</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>directed weighted connection matrix</p>
</div></blockquote>
<p><strong>bin_swaps</strong> : int</p>
<blockquote>
<div><p>average number of swaps in each edge binary randomization. Default
value is 5. 0 swaps implies no binary randomization.</p>
</div></blockquote>
<p><strong>wei_freq</strong> : float</p>
<blockquote>
<div><p>frequency of weight sorting in weighted randomization. 0&lt;=wei_freq&lt;1.
wei_freq == 1 implies that weights are sorted at each step.
wei_freq == 0.1 implies that weights sorted each 10th step (faster,</p>
<blockquote>
<div><p>default value)</p>
</div></blockquote>
<p>wei_freq == 0 implies no sorting of weights (not recommended)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>W0</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>randomized weighted connection matrix</p>
</div></blockquote>
<p><strong>R</strong> : 4-tuple of floats</p>
<blockquote class="last">
<div><p>Correlation coefficients between strength sequences of input and
output connection matrices, rpos_in, rpos_out, rneg_in, rneg_out</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<dl class="docutils">
<dt>The value of bin_swaps is ignored when binary topology is fully</dt>
<dd>connected (e.g. when the network has no negative weights).</dd>
<dt>Randomization may be better (and execution time will be slower) for</dt>
<dd>higher values of bin_swaps and wei_freq. Higher values of bin_swaps may
enable a more random binary organization, and higher values of wei_freq
may enable a more accurate conservation of strength sequences.</dd>
<dt>R are the correlation coefficients between positive and negative</dt>
<dd>in-strength and out-strength sequences of input and output connection
matrices and are used to evaluate the accuracy with which strengths
were preserved. Note that correlation coefficients may be a rough
measure of strength-sequence accuracy and one could implement more
formal tests (such as the Kolmogorov-Smirnov test) if desired.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.null_model_und_sign">
<tt class="descclassname">bct.</tt><tt class="descname">null_model_und_sign</tt><big>(</big><em>W</em>, <em>bin_swaps=5</em>, <em>wei_freq=0.1</em><big>)</big><a class="headerlink" href="#bct.null_model_und_sign" title="Permalink to this definition">¶</a></dt>
<dd><p>This function randomizes an undirected network with positive and
negative weights, while preserving the degree and strength
distributions. This function calls randmio_und.m</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>undirected weighted connection matrix</p>
</div></blockquote>
<p><strong>bin_swaps</strong> : int</p>
<blockquote>
<div><p>average number of swaps in each edge binary randomization. Default
value is 5. 0 swaps implies no binary randomization.</p>
</div></blockquote>
<p><strong>wei_freq</strong> : float</p>
<blockquote>
<div><p>frequency of weight sorting in weighted randomization. 0&lt;=wei_freq&lt;1.
wei_freq == 1 implies that weights are sorted at each step.
wei_freq == 0.1 implies that weights sorted each 10th step (faster,</p>
<blockquote>
<div><p>default value)</p>
</div></blockquote>
<p>wei_freq == 0 implies no sorting of weights (not recommended)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>W0</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>randomized weighted connection matrix</p>
</div></blockquote>
<p><strong>R</strong> : 4-tuple of floats</p>
<blockquote class="last">
<div><p>Correlation coefficients between strength sequences of input and
output connection matrices, rpos_in, rpos_out, rneg_in, rneg_out</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<dl class="docutils">
<dt>The value of bin_swaps is ignored when binary topology is fully</dt>
<dd>connected (e.g. when the network has no negative weights).</dd>
<dt>Randomization may be better (and execution time will be slower) for</dt>
<dd>higher values of bin_swaps and wei_freq. Higher values of bin_swaps
may enable a more random binary organization, and higher values of
wei_freq may enable a more accurate conservation of strength
sequences.</dd>
<dt>R are the correlation coefficients between positive and negative</dt>
<dd>strength sequences of input and output connection matrices and are
used to evaluate the accuracy with which strengths were preserved.
Note that correlation coefficients may be a rough measure of
strength-sequence accuracy and one could implement more formal tests
(such as the Kolmogorov-Smirnov test) if desired.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.randmio_dir_connected">
<tt class="descclassname">bct.</tt><tt class="descname">randmio_dir_connected</tt><big>(</big><em>R</em>, <em>itr</em><big>)</big><a class="headerlink" href="#bct.randmio_dir_connected" title="Permalink to this definition">¶</a></dt>
<dd><p>This function randomizes a directed network, while preserving the in-
and out-degree distributions. In weighted networks, the function
preserves the out-strength but not the in-strength distributions. The
function also ensures that the randomized network maintains
connectedness, the ability for every node to reach every other node in
the network. The input network for this function must be connected.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>directed binary/weighted connection matrix</p>
</div></blockquote>
<p><strong>itr</strong> : int</p>
<blockquote>
<div><p>rewiring parameter. Each edge is rewired approximately itr times.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>R</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>randomized network</p>
</div></blockquote>
<p><strong>eff</strong> : int</p>
<blockquote class="last">
<div><p>number of actual rewirings carried out</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.randmio_dir">
<tt class="descclassname">bct.</tt><tt class="descname">randmio_dir</tt><big>(</big><em>R</em>, <em>itr</em><big>)</big><a class="headerlink" href="#bct.randmio_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>This function randomizes a directed network, while preserving the in-
and out-degree distributions. In weighted networks, the function
preserves the out-strength but not the in-strength distributions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>directed binary/weighted connection matrix</p>
</div></blockquote>
<p><strong>itr</strong> : int</p>
<blockquote>
<div><p>rewiring parameter. Each edge is rewired approximately itr times.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>R</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>randomized network</p>
</div></blockquote>
<p><strong>eff</strong> : int</p>
<blockquote class="last">
<div><p>number of actual rewirings carried out</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.randmio_und_connected">
<tt class="descclassname">bct.</tt><tt class="descname">randmio_und_connected</tt><big>(</big><em>R</em>, <em>itr</em><big>)</big><a class="headerlink" href="#bct.randmio_und_connected" title="Permalink to this definition">¶</a></dt>
<dd><p>This function randomizes an undirected network, while preserving the
degree distribution. The function does not preserve the strength
distribution in weighted networks. The function also ensures that the
randomized network maintains connectedness, the ability for every node
to reach every other node in the network. The input network for this
function must be connected.</p>
<p>NOTE the changes to the BCT matlab function of the same name 
made in the Jan 2016 release 
have not been propagated to this function because of substantially
decreased time efficiency in the implementation. Expect these changes
to be merged eventually.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>undirected binary/weighted connection matrix</p>
</div></blockquote>
<p><strong>itr</strong> : int</p>
<blockquote>
<div><p>rewiring parameter. Each edge is rewired approximately itr times.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>R</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>randomized network</p>
</div></blockquote>
<p><strong>eff</strong> : int</p>
<blockquote class="last">
<div><p>number of actual rewirings carried out</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.randmio_und">
<tt class="descclassname">bct.</tt><tt class="descname">randmio_und</tt><big>(</big><em>R</em>, <em>itr</em><big>)</big><a class="headerlink" href="#bct.randmio_und" title="Permalink to this definition">¶</a></dt>
<dd><p>This function randomizes an undirected network, while preserving the
degree distribution. The function does not preserve the strength
distribution in weighted networks.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>undirected binary/weighted connection matrix</p>
</div></blockquote>
<p><strong>itr</strong> : int</p>
<blockquote>
<div><p>rewiring parameter. Each edge is rewired approximately itr times.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>R</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>randomized network</p>
</div></blockquote>
<p><strong>eff</strong> : int</p>
<blockquote class="last">
<div><p>number of actual rewirings carried out</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.randmio_und_signed">
<tt class="descclassname">bct.</tt><tt class="descname">randmio_und_signed</tt><big>(</big><em>R</em>, <em>itr</em><big>)</big><a class="headerlink" href="#bct.randmio_und_signed" title="Permalink to this definition">¶</a></dt>
<dd><p>This function randomizes an undirected weighted network with positive
and negative weights, while simultaneously preserving the degree
distribution of positive and negative weights. The function does not
preserve the strength distribution in weighted networks.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>undirected binary/weighted connection matrix</p>
</div></blockquote>
<p><strong>itr</strong> : int</p>
<blockquote>
<div><p>rewiring parameter. Each edge is rewired approximately itr times.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>R</strong> : NxN np.ndarray</p>
<blockquote class="last">
<div><p>randomized network</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.randomize_graph_partial_und">
<tt class="descclassname">bct.</tt><tt class="descname">randomize_graph_partial_und</tt><big>(</big><em>A</em>, <em>B</em>, <em>maxswap</em><big>)</big><a class="headerlink" href="#bct.randomize_graph_partial_und" title="Permalink to this definition">¶</a></dt>
<dd><p>A = RANDOMIZE_GRAPH_PARTIAL_UND(A,B,MAXSWAP) takes adjacency matrices A
and B and attempts to randomize matrix A by performing MAXSWAP
rewirings. The rewirings will avoid any spots where matrix B is
nonzero.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>undirected adjacency matrix to randomize</p>
</div></blockquote>
<p><strong>B</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>mask; edges to avoid</p>
</div></blockquote>
<p><strong>maxswap</strong> : int</p>
<blockquote>
<div><p>number of rewirings</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>A</strong> : NxN np.ndarray</p>
<blockquote class="last">
<div><p>randomized matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<ol class="arabic simple">
<li>Graph may become disconnected as a result of rewiring. Always</li>
</ol>
<blockquote>
<div>important to check.</div></blockquote>
<ol class="arabic simple" start="2">
<li>A can be weighted, though the weighted degree sequence will not be</li>
</ol>
<blockquote>
<div>preserved.</div></blockquote>
<ol class="arabic simple" start="3">
<li>A must be undirected.</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="bct.randomizer_bin_und">
<tt class="descclassname">bct.</tt><tt class="descname">randomizer_bin_und</tt><big>(</big><em>R</em>, <em>alpha</em><big>)</big><a class="headerlink" href="#bct.randomizer_bin_und" title="Permalink to this definition">¶</a></dt>
<dd><p>This function randomizes a binary undirected network, while preserving
the degree distribution. The function directly searches for rewirable
edge pairs (rather than trying to rewire edge pairs at random), and
hence avoids long loops and works especially well in dense matrices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary undirected connection matrix</p>
</div></blockquote>
<p><strong>alpha</strong> : float</p>
<blockquote>
<div><p>fraction of edges to rewire</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>R</strong> : NxN np.ndarray</p>
<blockquote class="last">
<div><p>randomized network</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="similarity">
<h2>Similarity<a class="headerlink" href="#similarity" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="bct.edge_nei_overlap_bd">
<tt class="descclassname">bct.</tt><tt class="descname">edge_nei_overlap_bd</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.edge_nei_overlap_bd" title="Permalink to this definition">¶</a></dt>
<dd><p>This function determines the neighbors of two nodes that are linked by
an edge, and then computes their overlap.  Connection matrix must be
binary and directed.  Entries of &#8216;EC&#8217; that are &#8216;inf&#8217; indicate that no
edge is present.  Entries of &#8216;EC&#8217; that are 0 denote &#8220;local bridges&#8221;,
i.e. edges that link completely non-overlapping neighborhoods.  Low
values of EC indicate edges that are &#8220;weak ties&#8221;.</p>
<p>If CIJ is weighted, the weights are ignored. Neighbors of a node can be
linked by incoming, outgoing, or reciprocal connections.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>directed binary/weighted connection matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>EC</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>edge neighborhood overlap matrix</p>
</div></blockquote>
<p><strong>ec</strong> : Kx1 np.ndarray</p>
<blockquote>
<div><p>edge neighborhood overlap per edge vector</p>
</div></blockquote>
<p><strong>degij</strong> : NxN np.ndarray</p>
<blockquote class="last">
<div><p>degrees of node pairs connected by each edge</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.edge_nei_overlap_bu">
<tt class="descclassname">bct.</tt><tt class="descname">edge_nei_overlap_bu</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.edge_nei_overlap_bu" title="Permalink to this definition">¶</a></dt>
<dd><p>This function determines the neighbors of two nodes that are linked by
an edge, and then computes their overlap.  Connection matrix must be
binary and directed.  Entries of &#8216;EC&#8217; that are &#8216;inf&#8217; indicate that no
edge is present.  Entries of &#8216;EC&#8217; that are 0 denote &#8220;local bridges&#8221;, i.e.
edges that link completely non-overlapping neighborhoods.  Low values
of EC indicate edges that are &#8220;weak ties&#8221;.</p>
<p>If CIJ is weighted, the weights are ignored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>undirected binary/weighted connection matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>EC</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>edge neighborhood overlap matrix</p>
</div></blockquote>
<p><strong>ec</strong> : Kx1 np.ndarray</p>
<blockquote>
<div><p>edge neighborhood overlap per edge vector</p>
</div></blockquote>
<p><strong>degij</strong> : NxN np.ndarray</p>
<blockquote class="last">
<div><p>degrees of node pairs connected by each edge</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.gtom">
<tt class="descclassname">bct.</tt><tt class="descname">gtom</tt><big>(</big><em>adj</em>, <em>nr_steps</em><big>)</big><a class="headerlink" href="#bct.gtom" title="Permalink to this definition">¶</a></dt>
<dd><p>The m-th step generalized topological overlap measure (GTOM) quantifies
the extent to which a pair of nodes have similar m-th step neighbors.
Mth-step neighbors are nodes that are reachable by a path of at most
length m.</p>
<p>This function computes the the M x M generalized topological overlap
measure (GTOM) matrix for number of steps, numSteps.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>adj</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>connection matrix</p>
</div></blockquote>
<p><strong>nr_steps</strong> : int</p>
<blockquote>
<div><p>number of steps</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>gt</strong> : NxN np.ndarray</p>
<blockquote class="last">
<div><p>GTOM matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>When numSteps is equal to 1, GTOM is identical to the topological
overlap measure (TOM) from reference [2]. In that case the &#8216;gt&#8217; matrix
records, for each pair of nodes, the fraction of neighbors the two
nodes share in common, where &#8220;neighbors&#8221; are one step removed. As
&#8216;numSteps&#8217; is increased, neighbors that are furter out are considered.
Elements of &#8216;gt&#8217; are bounded between 0 and 1.  The &#8216;gt&#8217; matrix can be
converted from a similarity to a distance matrix by taking 1-gt.</p>
</dd></dl>

<dl class="function">
<dt id="bct.matching_ind">
<tt class="descclassname">bct.</tt><tt class="descname">matching_ind</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.matching_ind" title="Permalink to this definition">¶</a></dt>
<dd><p>For any two nodes u and v, the matching index computes the amount of
overlap in the connection patterns of u and v. Self-connections and
u-v connections are ignored. The matching index is a symmetric
quantity, similar to a correlation or a dot product.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>adjacency matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Min</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>matching index for incoming connections</p>
</div></blockquote>
<p><strong>Mout</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>matching index for outgoing connections</p>
</div></blockquote>
<p><strong>Mall</strong> : NxN np.ndarray</p>
<blockquote class="last">
<div><p>matching index for all connections</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Does not use self- or cross connections for comparison.
Does not use connections that are not present in BOTH u and v.
All output matrices are calculated for upper triangular only.</p>
</dd></dl>

<dl class="function">
<dt id="bct.matching_ind_und">
<tt class="descclassname">bct.</tt><tt class="descname">matching_ind_und</tt><big>(</big><em>CIJ0</em><big>)</big><a class="headerlink" href="#bct.matching_ind_und" title="Permalink to this definition">¶</a></dt>
<dd><p>M0 = MATCHING_IND_UND(CIJ) computes matching index for undirected
graph specified by adjacency matrix CIJ. Matching index is a measure of
similarity between two nodes&#8217; connectivity profiles (excluding their
mutual connection, should it exist).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>undirected adjacency matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>M0</strong> : NxN np.ndarray</p>
<blockquote class="last">
<div><p>matching index matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.dice_pairwise_und">
<tt class="descclassname">bct.</tt><tt class="descname">dice_pairwise_und</tt><big>(</big><em>a1</em>, <em>a2</em><big>)</big><a class="headerlink" href="#bct.dice_pairwise_und" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates pairwise dice similarity for each vertex between two
matrices. Treats the matrices as binary and undirected.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>D</strong> : Nx1 np.ndarray</p>
<blockquote class="last">
<div><p>dice similarity vector</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.corr_flat_und">
<tt class="descclassname">bct.</tt><tt class="descname">corr_flat_und</tt><big>(</big><em>a1</em>, <em>a2</em><big>)</big><a class="headerlink" href="#bct.corr_flat_und" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the correlation coefficient between two flattened adjacency
matrices.  Only the upper triangular part is used to avoid double counting
undirected matrices.  Similarity metric for weighted matrices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A1</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>undirected matrix 1</p>
</div></blockquote>
<p><strong>A2</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>undirected matrix 2</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>r</strong> : float</p>
<blockquote class="last">
<div><p>Correlation coefficient describing edgewise similarity of a1 and a2</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.corr_flat_dir">
<tt class="descclassname">bct.</tt><tt class="descname">corr_flat_dir</tt><big>(</big><em>a1</em>, <em>a2</em><big>)</big><a class="headerlink" href="#bct.corr_flat_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the correlation coefficient between two flattened adjacency
matrices.  Similarity metric for weighted matrices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A1</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>directed matrix 1</p>
</div></blockquote>
<p><strong>A2</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>directed matrix 2</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>r</strong> : float</p>
<blockquote class="last">
<div><p>Correlation coefficient describing edgewise similarity of a1 and a2</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="visualization">
<h2>Visualization<a class="headerlink" href="#visualization" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="bct.adjacency_plot_und">
<tt class="descclassname">bct.</tt><tt class="descname">adjacency_plot_und</tt><big>(</big><em>A</em>, <em>coor</em>, <em>tube=False</em><big>)</big><a class="headerlink" href="#bct.adjacency_plot_und" title="Permalink to this definition">¶</a></dt>
<dd><p>This function in matlab is a visualization helper which translates an
adjacency matrix and an Nx3 matrix of spatial coordinates, and plots a
3D isometric network connecting the undirected unweighted nodes using a
specific plotting format. Including the formatted output is not useful at
all for bctpy since matplotlib will not be able to plot it in quite the
same way.</p>
<p>Instead of doing this, I have included code that will plot the adjacency
matrix onto nodes at the given spatial coordinates in mayavi</p>
<p>This routine is basically a less featureful version of the 3D brain in
cvu, the connectome visualization utility which I also maintain. cvu uses
freesurfer surfaces and annotations to get the node coordinates (rather
than leaving them up to the user) and has many other interactive
visualization features not included here for the sake of brevity.</p>
<p>There are other similar visualizations in the ConnectomeViewer and the
UCLA multimodal connectivity database.</p>
<p>Note that unlike other bctpy functions, this function depends on mayavi.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : Instance(Scene)</p>
<blockquote class="last">
<div><p>handle to a mayavi figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>To display the output interactively, call</p>
<p>fig=adjacency_plot_und(A,coor)
from mayavi import mlab
mlab.show()</p>
<p>Note: Thresholding the matrix is strongly recommended.  It is recommended
that the input matrix have fewer than 5000 total connections in order to
achieve reasonable performance and noncluttered visualization.</p>
</dd></dl>

<dl class="function">
<dt id="bct.align_matrices">
<tt class="descclassname">bct.</tt><tt class="descname">align_matrices</tt><big>(</big><em>m1</em>, <em>m2</em>, <em>dfun='sqrdiff'</em>, <em>verbose=False</em>, <em>H=1000000.0</em>, <em>Texp=1</em>, <em>T0=0.001</em>, <em>Hbrk=10</em><big>)</big><a class="headerlink" href="#bct.align_matrices" title="Permalink to this definition">¶</a></dt>
<dd><p>This function aligns two matrices relative to one another by reordering
the nodes in M2.  The function uses a version of simulated annealing.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>M1</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>first connection matrix</p>
</div></blockquote>
<p><strong>M2</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>second connection matrix</p>
</div></blockquote>
<p><strong>dfun</strong> : str</p>
<blockquote>
<div><dl class="docutils">
<dt>distance metric to use for matching</dt>
<dd><p class="first last">&#8216;absdiff&#8217; : absolute difference
&#8216;sqrdiff&#8217; : squared difference (default)
&#8216;cosang&#8217; : cosine of vector angle</p>
</dd>
</dl>
</div></blockquote>
<p><strong>verbose</strong> : bool</p>
<blockquote>
<div><p>print out cost at each iteration. Default False.</p>
</div></blockquote>
<p><strong>H</strong> : int</p>
<blockquote>
<div><p>annealing parameter, default value 1e6</p>
</div></blockquote>
<p><strong>Texp</strong> : int</p>
<blockquote>
<div><p>annealing parameter, default value 1. Coefficient of H s.t.
Texp0=1-Texp/H</p>
</div></blockquote>
<p><strong>T0</strong> : float</p>
<blockquote>
<div><p>annealing parameter, default value 1e-3</p>
</div></blockquote>
<p><strong>Hbrk</strong> : int</p>
<blockquote>
<div><p>annealing parameter, default value = 10. Coefficient of H s.t.
Hbrk0 = H/Hkbr</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Mreordered</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>reordered connection matrix M2</p>
</div></blockquote>
<p><strong>Mindices</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>reordered indices</p>
</div></blockquote>
<p><strong>cost</strong> : float</p>
<blockquote class="last">
<div><p>objective function distance between M1 and Mreordered</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Connection matrices can be weighted or binary, directed or undirected.
They must have the same number of nodes.  M1 can be entered in any
node ordering.</p>
<p>Note that in general, the outcome will depend on the initial condition
(the setting of the random number seed).  Also, there is no good way to
determine optimal annealing parameters in advance - these parameters
will need to be adjusted &#8220;by hand&#8221; (particularly H, Texp, T0, and Hbrk).
For large and/or dense matrices, it is highly recommended to perform
exploratory runs varying the settings of &#8216;H&#8217; and &#8216;Texp&#8217; and then select
the best values.</p>
<p>Based on extensive testing, it appears that T0 and Hbrk can remain
unchanged in most cases.  Texp may be varied from 1-1/H to 1-10/H, for
example.  H is the most important parameter - set to larger values as
the problem size increases.  Good solutions can be obtained for
matrices up to about 100 nodes.  It is advisable to run this function
multiple times and select the solution(s) with the lowest &#8216;cost&#8217;.</p>
<p>If the two matrices are related it may be very helpful to pre-align them
by reordering along their largest eigenvectors:</p>
<blockquote>
<div>[v,~] = eig(M1); v1 = abs(v(:,end)); [a1,b1] = sort(v1);
[v,~] = eig(M2); v2 = abs(v(:,end)); [a2,b2] = sort(v2);
[a,b,c] = overlapMAT2(M1(b1,b1),M2(b2,b2),&#8217;dfun&#8217;,1);</div></blockquote>
<p>Setting &#8216;Texp&#8217; to zero cancels annealing and uses a greedy algorithm
instead.</p>
</dd></dl>

<dl class="function">
<dt id="bct.backbone_wu">
<tt class="descclassname">bct.</tt><tt class="descname">backbone_wu</tt><big>(</big><em>CIJ</em>, <em>avgdeg</em><big>)</big><a class="headerlink" href="#bct.backbone_wu" title="Permalink to this definition">¶</a></dt>
<dd><p>The network backbone contains the dominant connections in the network
and may be used to aid network visualization. This function computes
the backbone of a given weighted and undirected connection matrix CIJ,
using a minimum-spanning-tree based algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>weighted undirected connection matrix</p>
</div></blockquote>
<p><strong>avgdeg</strong> : int</p>
<blockquote>
<div><p>desired average degree of backbone</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>CIJtree</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>connection matrix of the minimum spanning tree of CIJ</p>
</div></blockquote>
<p><strong>CIJclus</strong> : NxN np.ndarray</p>
<blockquote class="last">
<div><p>connection matrix of the minimum spanning tree plus strongest
connections up to some average degree &#8216;avgdeg&#8217;. Identical to CIJtree
if the degree requirement is already met.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>NOTE: nodes with zero strength are discarded.
NOTE: CIJclus will have a total average degree exactly equal to</p>
<blockquote>
<div>(or very close to) &#8216;avgdeg&#8217;.</div></blockquote>
<dl class="docutils">
<dt>NOTE: &#8216;avgdeg&#8217; backfill is handled slightly differently than in Hagmann</dt>
<dd>et al 2008.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.grid_communities">
<tt class="descclassname">bct.</tt><tt class="descname">grid_communities</tt><big>(</big><em>c</em><big>)</big><a class="headerlink" href="#bct.grid_communities" title="Permalink to this definition">¶</a></dt>
<dd><p>(X,Y,INDSORT) = GRID_COMMUNITIES(C) takes a vector of community
assignments C and returns three output arguments for visualizing the
communities. The third is INDSORT, which is an ordering of the vertices
so that nodes with the same community assignment are next to one
another. The first two arguments are vectors that, when overlaid on the
adjacency matrix using the PLOT function, highlight the communities.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>c</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>community assignments</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>bounds</strong> : list</p>
<blockquote>
<div><p>list containing the communities</p>
</div></blockquote>
<p><strong>indsort</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>indices</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Note: This function returns considerably different values than in
matlab due to differences between matplotlib and matlab.  This function
has been designed to work with matplotlib, as in the following example:</p>
<p>ci,_=modularity_und(adj)
bounds,ixes=grid_communities(ci)
pylab.imshow(adj[np.ix_(ixes,ixes)],interpolation=&#8217;none&#8217;,cmap=&#8217;BuGn&#8217;)
for b in bounds:</p>
<blockquote>
<div>pylab.axvline(x=b,color=&#8217;red&#8217;)
pylab.axhline(y=b,color=&#8217;red&#8217;)</div></blockquote>
<p>Note that I adapted the idea from the matlab function of the same name,
and have not tested the functionality extensively.</p>
</dd></dl>

<dl class="function">
<dt id="bct.reorderMAT">
<tt class="descclassname">bct.</tt><tt class="descname">reorderMAT</tt><big>(</big><em>m</em>, <em>H=5000</em>, <em>cost='line'</em><big>)</big><a class="headerlink" href="#bct.reorderMAT" title="Permalink to this definition">¶</a></dt>
<dd><p>This function reorders the connectivity matrix in order to place more
edges closer to the diagonal. This often helps in displaying community
structure, clusters, etc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>MAT</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>connection matrix</p>
</div></blockquote>
<p><strong>H</strong> : int</p>
<blockquote>
<div><p>number of reordering attempts</p>
</div></blockquote>
<p><strong>cost</strong> : str</p>
<blockquote>
<div><p>&#8216;line&#8217; or &#8216;circ&#8217; for shape of lattice (linear or ring lattice).
Default is linear lattice.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>MATreordered</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>reordered connection matrix</p>
</div></blockquote>
<p><strong>MATindices</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>reordered indices</p>
</div></blockquote>
<p><strong>MATcost</strong> : float</p>
<blockquote class="last">
<div><p>objective function cost of reordered matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>I&#8217;m not 100% sure how the algorithms between this and reorder_matrix
differ, but this code looks a ton sketchier and might have had some minor
bugs in it.  Considering reorder_matrix() does the same thing using a well
vetted simulated annealing algorithm, just use that. ~rlaplant</p>
</dd></dl>

<dl class="function">
<dt id="bct.reorder_matrix">
<tt class="descclassname">bct.</tt><tt class="descname">reorder_matrix</tt><big>(</big><em>m1</em>, <em>cost='line'</em>, <em>verbose=False</em>, <em>H=10000.0</em>, <em>Texp=10</em>, <em>T0=0.001</em>, <em>Hbrk=10</em><big>)</big><a class="headerlink" href="#bct.reorder_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>This function rearranges the nodes in matrix M1 such that the matrix
elements are squeezed along the main diagonal.  The function uses a
version of simulated annealing.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>M1</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>connection matrix weighted/binary directed/undirected</p>
</div></blockquote>
<p><strong>cost</strong> : str</p>
<blockquote>
<div><p>&#8216;line&#8217; or &#8216;circ&#8217; for shape of lattice (linear or ring lattice).
Default is linear lattice.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool</p>
<blockquote>
<div><p>print out cost at each iteration. Default False.</p>
</div></blockquote>
<p><strong>H</strong> : int</p>
<blockquote>
<div><p>annealing parameter, default value 1e6</p>
</div></blockquote>
<p><strong>Texp</strong> : int</p>
<blockquote>
<div><p>annealing parameter, default value 1. Coefficient of H s.t.
Texp0=1-Texp/H</p>
</div></blockquote>
<p><strong>T0</strong> : float</p>
<blockquote>
<div><p>annealing parameter, default value 1e-3</p>
</div></blockquote>
<p><strong>Hbrk</strong> : int</p>
<blockquote>
<div><p>annealing parameter, default value = 10. Coefficient of H s.t.
Hbrk0 = H/Hkbr</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Mreordered</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>reordered connection matrix</p>
</div></blockquote>
<p><strong>Mindices</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>reordered indices</p>
</div></blockquote>
<p><strong>Mcost</strong> : float</p>
<blockquote class="last">
<div><p>objective function cost of reordered matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Note that in general, the outcome will depend on the initial condition
(the setting of the random number seed).  Also, there is no good way to
determine optimal annealing parameters in advance - these paramters
will need to be adjusted &#8220;by hand&#8221; (particularly H, Texp, and T0).
For large and/or dense matrices, it is highly recommended to perform
exploratory runs varying the settings of &#8216;H&#8217; and &#8216;Texp&#8217; and then select
the best values.</p>
<p>Based on extensive testing, it appears that T0 and Hbrk can remain
unchanged in most cases.  Texp may be varied from 1-1/H to 1-10/H, for
example.  H is the most important parameter - set to larger values as
the problem size increases.  It is advisable to run this function
multiple times and select the solution(s) with the lowest &#8216;cost&#8217;.</p>
<p>Setting &#8216;Texp&#8217; to zero cancels annealing and uses a greedy algorithm
instead.</p>
</dd></dl>

<dl class="function">
<dt id="bct.reorder_mod">
<tt class="descclassname">bct.</tt><tt class="descname">reorder_mod</tt><big>(</big><em>A</em>, <em>ci</em><big>)</big><a class="headerlink" href="#bct.reorder_mod" title="Permalink to this definition">¶</a></dt>
<dd><p>This function reorders the connectivity matrix by modular structure and
may hence be useful in visualization of modular structure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>binary/weighted connectivity matrix</p>
</div></blockquote>
<p><strong>ci</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>module affiliation vector</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>On</strong> : Nx1 np.ndarray</p>
<blockquote>
<div><p>new node order</p>
</div></blockquote>
<p><strong>Ar</strong> : NxN np.ndarray</p>
<blockquote class="last">
<div><p>reordered connectivity matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bct.writetoPAJ">
<tt class="descclassname">bct.</tt><tt class="descname">writetoPAJ</tt><big>(</big><em>CIJ</em>, <em>fname</em>, <em>directed</em><big>)</big><a class="headerlink" href="#bct.writetoPAJ" title="Permalink to this definition">¶</a></dt>
<dd><p>This function writes a Pajek .net file from a numpy matrix</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>CIJ</strong> : NxN np.ndarray</p>
<blockquote>
<div><p>adjacency matrix</p>
</div></blockquote>
<p><strong>fname</strong> : str</p>
<blockquote>
<div><p>filename</p>
</div></blockquote>
<p><strong>directed</strong> : bool</p>
<blockquote class="last">
<div><p>True if the network is directed and False otherwise. The data format
may be required to know this for some reason so I am afraid to just
use directed as the default value.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="network-based-statistic">
<h1>Network Based Statistic<a class="headerlink" href="#network-based-statistic" title="Permalink to this headline">¶</a></h1>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Brain Connectivity Toolbox</a><ul>
<li><a class="reference internal" href="#centrality">Centrality</a></li>
<li><a class="reference internal" href="#clustering">Clustering</a></li>
<li><a class="reference internal" href="#core">Core</a></li>
<li><a class="reference internal" href="#degree">Degree</a></li>
<li><a class="reference internal" href="#distance">Distance</a></li>
<li><a class="reference internal" href="#modularity">Modularity</a></li>
<li><a class="reference internal" href="#motif">Motif</a></li>
<li><a class="reference internal" href="#miscellaneous">Miscellaneous</a></li>
<li><a class="reference internal" href="#physical-connectivity">Physical Connectivity</a></li>
<li><a class="reference internal" href="#reference">Reference</a></li>
<li><a class="reference internal" href="#similarity">Similarity</a></li>
<li><a class="reference internal" href="#visualization">Visualization</a></li>
</ul>
</li>
<li><a class="reference internal" href="#network-based-statistic">Network Based Statistic</a></li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/bct.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li><a href="index.html">bct 0.4 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, rlaplant.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>